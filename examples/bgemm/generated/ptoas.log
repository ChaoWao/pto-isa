module attributes {"pto.device-spec" = "Ascend910B1"} {
  func.func @bgemm_kernel(%arg0: index, %arg1: memref<?xf16>, %arg2: memref<?xf16>, %arg3: memref<?xf32>) {
    %c1 = arith.constant 1 : index
    %c256 = arith.constant 256 : index
    %reinterpret_cast = memref.reinterpret_cast %arg1 to offset: [0], sizes: [%c1, %c1, %c1, %c256, %c256], strides: [%c1, %c1, %c1, %c256, %c1] : memref<?xf16> to memref<?x?x?x?x?xf16, strided<[?, ?, ?, ?, ?], offset: ?>>
    %reinterpret_cast_0 = memref.reinterpret_cast %arg2 to offset: [0], sizes: [%c1, %c1, %c1, %c256, %c256], strides: [%c1, %c1, %c1, %c1, %c256] : memref<?xf16> to memref<?x?x?x?x?xf16, strided<[?, ?, ?, ?, ?], offset: ?>>
    %reinterpret_cast_1 = memref.reinterpret_cast %arg3 to offset: [0], sizes: [%c1, %c1, %c1, %c256, %c256], strides: [%c1, %c1, %c1, %c256, %c1] : memref<?xf32> to memref<?x?x?x?x?xf32, strided<[?, ?, ?, ?, ?], offset: ?>>
    %alloc = memref.alloc() : memref<128x64xf16, strided<[64, 1]>, #pto.address_space<mat>>
    %0 = pto.bind_tile %alloc {config = #pto.tile_buf_config<blayout=1 : i32, slayout=1 : i32, s_fractal_size=512, pad=0 : i32>} : memref<128x64xf16, strided<[64, 1]>, #pto.address_space<mat>> -> memref<128x64xf16, strided<[64, 1], offset: ?>, #pto.address_space<mat>>
    %alloc_2 = memref.alloc() : memref<64x256xf16, strided<[256, 1]>, #pto.address_space<mat>>
    %1 = pto.bind_tile %alloc_2 {config = #pto.tile_buf_config<blayout=0 : i32, slayout=2 : i32, s_fractal_size=512, pad=0 : i32>} : memref<64x256xf16, strided<[256, 1]>, #pto.address_space<mat>> -> memref<64x256xf16, strided<[256, 1], offset: ?>, #pto.address_space<mat>>
    %alloc_3 = memref.alloc() : memref<128x64xf16, strided<[64, 1]>, #pto.address_space<left>>
    %2 = pto.bind_tile %alloc_3 {config = #pto.tile_buf_config<blayout=0 : i32, slayout=1 : i32, s_fractal_size=512, pad=0 : i32>} : memref<128x64xf16, strided<[64, 1]>, #pto.address_space<left>> -> memref<128x64xf16, strided<[64, 1], offset: ?>, #pto.address_space<left>>
    %alloc_4 = memref.alloc() : memref<64x256xf16, strided<[256, 1]>, #pto.address_space<right>>
    %3 = pto.bind_tile %alloc_4 {config = #pto.tile_buf_config<blayout=0 : i32, slayout=2 : i32, s_fractal_size=512, pad=0 : i32>} : memref<64x256xf16, strided<[256, 1]>, #pto.address_space<right>> -> memref<64x256xf16, strided<[256, 1], offset: ?>, #pto.address_space<right>>
    %alloc_5 = memref.alloc() : memref<128x256xf32, strided<[256, 1]>, #pto.address_space<acc>>
    %4 = pto.bind_tile %alloc_5 {config = #pto.tile_buf_config<blayout=1 : i32, slayout=1 : i32, s_fractal_size=1024, pad=0 : i32>} : memref<128x256xf32, strided<[256, 1]>, #pto.address_space<acc>> -> memref<128x256xf32, strided<[256, 1], offset: ?>, #pto.address_space<acc>>
    %5 = arith.muli %c1, %c1 : index
    %6 = arith.divsi %arg0, %5 : index
    %7 = arith.remsi %arg0, %5 : index
    %8 = arith.divsi %c256, %c1 : index
    %9 = arith.divsi %c256, %c1 : index
    %c128 = arith.constant 128 : index
    %10 = arith.divsi %8, %c128 : index
    %11 = arith.divsi %9, %c256 : index
    %c64 = arith.constant 64 : index
    %12 = arith.divsi %c256, %c64 : index
    %13 = arith.remsi %7, %c1 : index
    %14 = arith.divsi %7, %c1 : index
    %15 = arith.cmpi slt, %6, %c1 : index
    scf.if %15 {
      %16 = arith.cmpi slt, %14, %c1 : index
      scf.if %16 {
        %17 = arith.muli %6, %c256 : index
        %18 = arith.muli %6, %c256 : index
        %19 = arith.muli %13, %8 : index
        %20 = arith.addi %17, %19 : index
        %21 = arith.muli %14, %9 : index
        %c0 = arith.constant 0 : index
        scf.for %arg4 = %c0 to %10 step %c1 {
          %22 = arith.muli %arg4, %c128 : index
          %23 = arith.addi %20, %22 : index
          scf.for %arg5 = %c0 to %11 step %c1 {
            %24 = arith.muli %arg5, %c256 : index
            %25 = arith.addi %21, %24 : index
            %subview = memref.subview %reinterpret_cast[0, 0, 0, %23, 0] [1, 1, 1, 128, 64] [1, 1, 1, 1, 1] : memref<?x?x?x?x?xf16, strided<[?, ?, ?, ?, ?], offset: ?>> to memref<1x1x1x128x64xf16, strided<[?, ?, ?, ?, ?], offset: ?>>
            pto.load_dps ins(%subview : memref<1x1x1x128x64xf16, strided<[?, ?, ?, ?, ?], offset: ?>>) outs(%0 : memref<128x64xf16, strided<[64, 1], offset: ?>, #pto.address_space<mat>>)
            %subview_6 = memref.subview %reinterpret_cast_0[0, 0, 0, %18, %25] [1, 1, 1, 64, 256] [1, 1, 1, 1, 1] : memref<?x?x?x?x?xf16, strided<[?, ?, ?, ?, ?], offset: ?>> to memref<1x1x1x64x256xf16, strided<[?, ?, ?, ?, ?], offset: ?>>
            pto.load_dps ins(%subview_6 : memref<1x1x1x64x256xf16, strided<[?, ?, ?, ?, ?], offset: ?>>) outs(%1 : memref<64x256xf16, strided<[256, 1], offset: ?>, #pto.address_space<mat>>)
            pto.mov_dps ins(%0 : memref<128x64xf16, strided<[64, 1], offset: ?>, #pto.address_space<mat>>) outs(%2 : memref<128x64xf16, strided<[64, 1], offset: ?>, #pto.address_space<left>>)
            pto.mov_dps ins(%1 : memref<64x256xf16, strided<[256, 1], offset: ?>, #pto.address_space<mat>>) outs(%3 : memref<64x256xf16, strided<[256, 1], offset: ?>, #pto.address_space<right>>)
            pto.matmul_dps ins(%2, %3 : memref<128x64xf16, strided<[64, 1], offset: ?>, #pto.address_space<left>>, memref<64x256xf16, strided<[256, 1], offset: ?>, #pto.address_space<right>>) outs(%4 : memref<128x256xf32, strided<[256, 1], offset: ?>, #pto.address_space<acc>>)
            scf.for %arg6 = %c1 to %12 step %c1 {
              %26 = arith.muli %arg6, %c64 : index
              %subview_8 = memref.subview %reinterpret_cast[0, 0, 0, %23, %26] [1, 1, 1, 128, 64] [1, 1, 1, 1, 1] : memref<?x?x?x?x?xf16, strided<[?, ?, ?, ?, ?], offset: ?>> to memref<1x1x1x128x64xf16, strided<[?, ?, ?, ?, ?], offset: ?>>
              pto.load_dps ins(%subview_8 : memref<1x1x1x128x64xf16, strided<[?, ?, ?, ?, ?], offset: ?>>) outs(%0 : memref<128x64xf16, strided<[64, 1], offset: ?>, #pto.address_space<mat>>)
              %27 = arith.addi %18, %26 : index
              %subview_9 = memref.subview %reinterpret_cast_0[0, 0, 0, %27, %25] [1, 1, 1, 64, 256] [1, 1, 1, 1, 1] : memref<?x?x?x?x?xf16, strided<[?, ?, ?, ?, ?], offset: ?>> to memref<1x1x1x64x256xf16, strided<[?, ?, ?, ?, ?], offset: ?>>
              pto.load_dps ins(%subview_9 : memref<1x1x1x64x256xf16, strided<[?, ?, ?, ?, ?], offset: ?>>) outs(%1 : memref<64x256xf16, strided<[256, 1], offset: ?>, #pto.address_space<mat>>)
              pto.mov_dps ins(%0 : memref<128x64xf16, strided<[64, 1], offset: ?>, #pto.address_space<mat>>) outs(%2 : memref<128x64xf16, strided<[64, 1], offset: ?>, #pto.address_space<left>>)
              pto.mov_dps ins(%1 : memref<64x256xf16, strided<[256, 1], offset: ?>, #pto.address_space<mat>>) outs(%3 : memref<64x256xf16, strided<[256, 1], offset: ?>, #pto.address_space<right>>)
              pto.matmul_acc_dps ins(%4, %2, %3 : memref<128x256xf32, strided<[256, 1], offset: ?>, #pto.address_space<acc>>, memref<128x64xf16, strided<[64, 1], offset: ?>, #pto.address_space<left>>, memref<64x256xf16, strided<[256, 1], offset: ?>, #pto.address_space<right>>) outs(%4 : memref<128x256xf32, strided<[256, 1], offset: ?>, #pto.address_space<acc>>)
            }
            %subview_7 = memref.subview %reinterpret_cast_1[0, 0, 0, %23, %25] [1, 1, 1, 128, 256] [1, 1, 1, 1, 1] : memref<?x?x?x?x?xf32, strided<[?, ?, ?, ?, ?], offset: ?>> to memref<1x1x1x128x256xf32, strided<[?, ?, ?, ?, ?], offset: ?>>
            pto.store_dps ins(%4 : memref<128x256xf32, strided<[256, 1], offset: ?>, #pto.address_space<acc>>) outs(%subview_7 : memref<1x1x1x128x256xf32, strided<[?, ?, ?, ?, ?], offset: ?>>)
          }
        }
      }
    }
    return
  }
}
Hello PTO Infer Mem Scope!
module attributes {"pto.device-spec" = "Ascend910B1"} {
  func.func @bgemm_kernel(%arg0: index, %arg1: memref<?xf16>, %arg2: memref<?xf16>, %arg3: memref<?xf32>) {
    %c1 = arith.constant 1 : index
    %c256 = arith.constant 256 : index
    %reinterpret_cast = memref.reinterpret_cast %arg1 to offset: [0], sizes: [%c1, %c1, %c1, %c256, %c256], strides: [%c1, %c1, %c1, %c256, %c1] : memref<?xf16> to memref<?x?x?x?x?xf16, strided<[?, ?, ?, ?, ?], offset: ?>>
    %reinterpret_cast_0 = memref.reinterpret_cast %arg2 to offset: [0], sizes: [%c1, %c1, %c1, %c256, %c256], strides: [%c1, %c1, %c1, %c1, %c256] : memref<?xf16> to memref<?x?x?x?x?xf16, strided<[?, ?, ?, ?, ?], offset: ?>>
    %reinterpret_cast_1 = memref.reinterpret_cast %arg3 to offset: [0], sizes: [%c1, %c1, %c1, %c256, %c256], strides: [%c1, %c1, %c1, %c256, %c1] : memref<?xf32> to memref<?x?x?x?x?xf32, strided<[?, ?, ?, ?, ?], offset: ?>>
    %alloc = memref.alloc() : memref<128x64xf16, strided<[64, 1]>, #pto.address_space<mat>>
    %0 = pto.bind_tile %alloc {config = #pto.tile_buf_config<blayout=1 : i32, slayout=1 : i32, s_fractal_size=512, pad=0 : i32>} : memref<128x64xf16, strided<[64, 1]>, #pto.address_space<mat>> -> memref<128x64xf16, strided<[64, 1], offset: ?>, #pto.address_space<mat>>
    %alloc_2 = memref.alloc() : memref<64x256xf16, strided<[256, 1]>, #pto.address_space<mat>>
    %1 = pto.bind_tile %alloc_2 {config = #pto.tile_buf_config<blayout=0 : i32, slayout=2 : i32, s_fractal_size=512, pad=0 : i32>} : memref<64x256xf16, strided<[256, 1]>, #pto.address_space<mat>> -> memref<64x256xf16, strided<[256, 1], offset: ?>, #pto.address_space<mat>>
    %alloc_3 = memref.alloc() : memref<128x64xf16, strided<[64, 1]>, #pto.address_space<left>>
    %2 = pto.bind_tile %alloc_3 {config = #pto.tile_buf_config<blayout=0 : i32, slayout=1 : i32, s_fractal_size=512, pad=0 : i32>} : memref<128x64xf16, strided<[64, 1]>, #pto.address_space<left>> -> memref<128x64xf16, strided<[64, 1], offset: ?>, #pto.address_space<left>>
    %alloc_4 = memref.alloc() : memref<64x256xf16, strided<[256, 1]>, #pto.address_space<right>>
    %3 = pto.bind_tile %alloc_4 {config = #pto.tile_buf_config<blayout=0 : i32, slayout=2 : i32, s_fractal_size=512, pad=0 : i32>} : memref<64x256xf16, strided<[256, 1]>, #pto.address_space<right>> -> memref<64x256xf16, strided<[256, 1], offset: ?>, #pto.address_space<right>>
    %alloc_5 = memref.alloc() : memref<128x256xf32, strided<[256, 1]>, #pto.address_space<acc>>
    %4 = pto.bind_tile %alloc_5 {config = #pto.tile_buf_config<blayout=1 : i32, slayout=1 : i32, s_fractal_size=1024, pad=0 : i32>} : memref<128x256xf32, strided<[256, 1]>, #pto.address_space<acc>> -> memref<128x256xf32, strided<[256, 1], offset: ?>, #pto.address_space<acc>>
    %5 = arith.muli %c1, %c1 : index
    %6 = arith.divsi %arg0, %5 : index
    %7 = arith.remsi %arg0, %5 : index
    %8 = arith.divsi %c256, %c1 : index
    %9 = arith.divsi %c256, %c1 : index
    %c128 = arith.constant 128 : index
    %10 = arith.divsi %8, %c128 : index
    %11 = arith.divsi %9, %c256 : index
    %c64 = arith.constant 64 : index
    %12 = arith.divsi %c256, %c64 : index
    %13 = arith.remsi %7, %c1 : index
    %14 = arith.divsi %7, %c1 : index
    %15 = arith.cmpi slt, %6, %c1 : index
    scf.if %15 {
      %16 = arith.cmpi slt, %14, %c1 : index
      scf.if %16 {
        %17 = arith.muli %6, %c256 : index
        %18 = arith.muli %6, %c256 : index
        %19 = arith.muli %13, %8 : index
        %20 = arith.addi %17, %19 : index
        %21 = arith.muli %14, %9 : index
        %c0 = arith.constant 0 : index
        scf.for %arg4 = %c0 to %10 step %c1 {
          %22 = arith.muli %arg4, %c128 : index
          %23 = arith.addi %20, %22 : index
          scf.for %arg5 = %c0 to %11 step %c1 {
            %24 = arith.muli %arg5, %c256 : index
            %25 = arith.addi %21, %24 : index
            %subview = memref.subview %reinterpret_cast[0, 0, 0, %23, 0] [1, 1, 1, 128, 64] [1, 1, 1, 1, 1] : memref<?x?x?x?x?xf16, strided<[?, ?, ?, ?, ?], offset: ?>> to memref<1x1x1x128x64xf16, strided<[?, ?, ?, ?, ?], offset: ?>>
            pto.load_dps ins(%subview : memref<1x1x1x128x64xf16, strided<[?, ?, ?, ?, ?], offset: ?>>) outs(%0 : memref<128x64xf16, strided<[64, 1], offset: ?>, #pto.address_space<mat>>)
            %subview_6 = memref.subview %reinterpret_cast_0[0, 0, 0, %18, %25] [1, 1, 1, 64, 256] [1, 1, 1, 1, 1] : memref<?x?x?x?x?xf16, strided<[?, ?, ?, ?, ?], offset: ?>> to memref<1x1x1x64x256xf16, strided<[?, ?, ?, ?, ?], offset: ?>>
            pto.load_dps ins(%subview_6 : memref<1x1x1x64x256xf16, strided<[?, ?, ?, ?, ?], offset: ?>>) outs(%1 : memref<64x256xf16, strided<[256, 1], offset: ?>, #pto.address_space<mat>>)
            pto.mov_dps ins(%0 : memref<128x64xf16, strided<[64, 1], offset: ?>, #pto.address_space<mat>>) outs(%2 : memref<128x64xf16, strided<[64, 1], offset: ?>, #pto.address_space<left>>)
            pto.mov_dps ins(%1 : memref<64x256xf16, strided<[256, 1], offset: ?>, #pto.address_space<mat>>) outs(%3 : memref<64x256xf16, strided<[256, 1], offset: ?>, #pto.address_space<right>>)
            pto.matmul_dps ins(%2, %3 : memref<128x64xf16, strided<[64, 1], offset: ?>, #pto.address_space<left>>, memref<64x256xf16, strided<[256, 1], offset: ?>, #pto.address_space<right>>) outs(%4 : memref<128x256xf32, strided<[256, 1], offset: ?>, #pto.address_space<acc>>)
            scf.for %arg6 = %c1 to %12 step %c1 {
              %26 = arith.muli %arg6, %c64 : index
              %subview_8 = memref.subview %reinterpret_cast[0, 0, 0, %23, %26] [1, 1, 1, 128, 64] [1, 1, 1, 1, 1] : memref<?x?x?x?x?xf16, strided<[?, ?, ?, ?, ?], offset: ?>> to memref<1x1x1x128x64xf16, strided<[?, ?, ?, ?, ?], offset: ?>>
              pto.load_dps ins(%subview_8 : memref<1x1x1x128x64xf16, strided<[?, ?, ?, ?, ?], offset: ?>>) outs(%0 : memref<128x64xf16, strided<[64, 1], offset: ?>, #pto.address_space<mat>>)
              %27 = arith.addi %18, %26 : index
              %subview_9 = memref.subview %reinterpret_cast_0[0, 0, 0, %27, %25] [1, 1, 1, 64, 256] [1, 1, 1, 1, 1] : memref<?x?x?x?x?xf16, strided<[?, ?, ?, ?, ?], offset: ?>> to memref<1x1x1x64x256xf16, strided<[?, ?, ?, ?, ?], offset: ?>>
              pto.load_dps ins(%subview_9 : memref<1x1x1x64x256xf16, strided<[?, ?, ?, ?, ?], offset: ?>>) outs(%1 : memref<64x256xf16, strided<[256, 1], offset: ?>, #pto.address_space<mat>>)
              pto.mov_dps ins(%0 : memref<128x64xf16, strided<[64, 1], offset: ?>, #pto.address_space<mat>>) outs(%2 : memref<128x64xf16, strided<[64, 1], offset: ?>, #pto.address_space<left>>)
              pto.mov_dps ins(%1 : memref<64x256xf16, strided<[256, 1], offset: ?>, #pto.address_space<mat>>) outs(%3 : memref<64x256xf16, strided<[256, 1], offset: ?>, #pto.address_space<right>>)
              pto.matmul_acc_dps ins(%4, %2, %3 : memref<128x256xf32, strided<[256, 1], offset: ?>, #pto.address_space<acc>>, memref<128x64xf16, strided<[64, 1], offset: ?>, #pto.address_space<left>>, memref<64x256xf16, strided<[256, 1], offset: ?>, #pto.address_space<right>>) outs(%4 : memref<128x256xf32, strided<[256, 1], offset: ?>, #pto.address_space<acc>>)
            }
            %subview_7 = memref.subview %reinterpret_cast_1[0, 0, 0, %23, %25] [1, 1, 1, 128, 256] [1, 1, 1, 1, 1] : memref<?x?x?x?x?xf32, strided<[?, ?, ?, ?, ?], offset: ?>> to memref<1x1x1x128x256xf32, strided<[?, ?, ?, ?, ?], offset: ?>>
            pto.store_dps ins(%4 : memref<128x256xf32, strided<[256, 1], offset: ?>, #pto.address_space<acc>>) outs(%subview_7 : memref<1x1x1x128x256xf32, strided<[?, ?, ?, ?, ?], offset: ?>>)
          }
        }
      }
    }
    return
  }
}
end PTO Infer Mem Scope!
module attributes {"pto.device-spec" = "Ascend910B1"} {
  func.func @bgemm_kernel(%arg0: index, %arg1: memref<?xf16, #pto.address_space<gm>>, %arg2: memref<?xf16, #pto.address_space<gm>>, %arg3: memref<?xf32, #pto.address_space<gm>>) {
    %c1 = arith.constant 1 : index
    %c256 = arith.constant 256 : index
    %reinterpret_cast = memref.reinterpret_cast %arg1 to offset: [0], sizes: [%c1, %c1, %c1, %c256, %c256], strides: [%c1, %c1, %c1, %c256, %c1] : memref<?xf16, #pto.address_space<gm>> to memref<?x?x?x?x?xf16, strided<[?, ?, ?, ?, ?], offset: ?>, #pto.address_space<gm>>
    %reinterpret_cast_0 = memref.reinterpret_cast %arg2 to offset: [0], sizes: [%c1, %c1, %c1, %c256, %c256], strides: [%c1, %c1, %c1, %c1, %c256] : memref<?xf16, #pto.address_space<gm>> to memref<?x?x?x?x?xf16, strided<[?, ?, ?, ?, ?], offset: ?>, #pto.address_space<gm>>
    %reinterpret_cast_1 = memref.reinterpret_cast %arg3 to offset: [0], sizes: [%c1, %c1, %c1, %c256, %c256], strides: [%c1, %c1, %c1, %c256, %c1] : memref<?xf32, #pto.address_space<gm>> to memref<?x?x?x?x?xf32, strided<[?, ?, ?, ?, ?], offset: ?>, #pto.address_space<gm>>
    %alloc = memref.alloc() : memref<128x64xf16, strided<[64, 1]>, #pto.address_space<mat>>
    %0 = pto.bind_tile %alloc {config = #pto.tile_buf_config<blayout=1 : i32, slayout=1 : i32, s_fractal_size=512, pad=0 : i32>} : memref<128x64xf16, strided<[64, 1]>, #pto.address_space<mat>> -> memref<128x64xf16, strided<[64, 1], offset: ?>, #pto.address_space<mat>>
    %alloc_2 = memref.alloc() : memref<64x256xf16, strided<[256, 1]>, #pto.address_space<mat>>
    %1 = pto.bind_tile %alloc_2 {config = #pto.tile_buf_config<blayout=0 : i32, slayout=2 : i32, s_fractal_size=512, pad=0 : i32>} : memref<64x256xf16, strided<[256, 1]>, #pto.address_space<mat>> -> memref<64x256xf16, strided<[256, 1], offset: ?>, #pto.address_space<mat>>
    %alloc_3 = memref.alloc() : memref<128x64xf16, strided<[64, 1]>, #pto.address_space<left>>
    %2 = pto.bind_tile %alloc_3 {config = #pto.tile_buf_config<blayout=0 : i32, slayout=1 : i32, s_fractal_size=512, pad=0 : i32>} : memref<128x64xf16, strided<[64, 1]>, #pto.address_space<left>> -> memref<128x64xf16, strided<[64, 1], offset: ?>, #pto.address_space<left>>
    %alloc_4 = memref.alloc() : memref<64x256xf16, strided<[256, 1]>, #pto.address_space<right>>
    %3 = pto.bind_tile %alloc_4 {config = #pto.tile_buf_config<blayout=0 : i32, slayout=2 : i32, s_fractal_size=512, pad=0 : i32>} : memref<64x256xf16, strided<[256, 1]>, #pto.address_space<right>> -> memref<64x256xf16, strided<[256, 1], offset: ?>, #pto.address_space<right>>
    %alloc_5 = memref.alloc() : memref<128x256xf32, strided<[256, 1]>, #pto.address_space<acc>>
    %4 = pto.bind_tile %alloc_5 {config = #pto.tile_buf_config<blayout=1 : i32, slayout=1 : i32, s_fractal_size=1024, pad=0 : i32>} : memref<128x256xf32, strided<[256, 1]>, #pto.address_space<acc>> -> memref<128x256xf32, strided<[256, 1], offset: ?>, #pto.address_space<acc>>
    %5 = arith.muli %c1, %c1 : index
    %6 = arith.divsi %arg0, %5 : index
    %7 = arith.remsi %arg0, %5 : index
    %8 = arith.divsi %c256, %c1 : index
    %9 = arith.divsi %c256, %c1 : index
    %c128 = arith.constant 128 : index
    %10 = arith.divsi %8, %c128 : index
    %11 = arith.divsi %9, %c256 : index
    %c64 = arith.constant 64 : index
    %12 = arith.divsi %c256, %c64 : index
    %13 = arith.remsi %7, %c1 : index
    %14 = arith.divsi %7, %c1 : index
    %15 = arith.cmpi slt, %6, %c1 : index
    scf.if %15 {
      %16 = arith.cmpi slt, %14, %c1 : index
      scf.if %16 {
        %17 = arith.muli %6, %c256 : index
        %18 = arith.muli %6, %c256 : index
        %19 = arith.muli %13, %8 : index
        %20 = arith.addi %17, %19 : index
        %21 = arith.muli %14, %9 : index
        %c0 = arith.constant 0 : index
        scf.for %arg4 = %c0 to %10 step %c1 {
          %22 = arith.muli %arg4, %c128 : index
          %23 = arith.addi %20, %22 : index
          scf.for %arg5 = %c0 to %11 step %c1 {
            %24 = arith.muli %arg5, %c256 : index
            %25 = arith.addi %21, %24 : index
            %subview = memref.subview %reinterpret_cast[0, 0, 0, %23, 0] [1, 1, 1, 128, 64] [1, 1, 1, 1, 1] : memref<?x?x?x?x?xf16, strided<[?, ?, ?, ?, ?], offset: ?>, #pto.address_space<gm>> to memref<1x1x1x128x64xf16, strided<[?, ?, ?, ?, ?], offset: ?>, #pto.address_space<gm>>
            pto.load_dps ins(%subview : memref<1x1x1x128x64xf16, strided<[?, ?, ?, ?, ?], offset: ?>, #pto.address_space<gm>>) outs(%0 : memref<128x64xf16, strided<[64, 1], offset: ?>, #pto.address_space<mat>>)
            %subview_6 = memref.subview %reinterpret_cast_0[0, 0, 0, %18, %25] [1, 1, 1, 64, 256] [1, 1, 1, 1, 1] : memref<?x?x?x?x?xf16, strided<[?, ?, ?, ?, ?], offset: ?>, #pto.address_space<gm>> to memref<1x1x1x64x256xf16, strided<[?, ?, ?, ?, ?], offset: ?>, #pto.address_space<gm>>
            pto.load_dps ins(%subview_6 : memref<1x1x1x64x256xf16, strided<[?, ?, ?, ?, ?], offset: ?>, #pto.address_space<gm>>) outs(%1 : memref<64x256xf16, strided<[256, 1], offset: ?>, #pto.address_space<mat>>)
            pto.mov_dps ins(%0 : memref<128x64xf16, strided<[64, 1], offset: ?>, #pto.address_space<mat>>) outs(%2 : memref<128x64xf16, strided<[64, 1], offset: ?>, #pto.address_space<left>>)
            pto.mov_dps ins(%1 : memref<64x256xf16, strided<[256, 1], offset: ?>, #pto.address_space<mat>>) outs(%3 : memref<64x256xf16, strided<[256, 1], offset: ?>, #pto.address_space<right>>)
            pto.matmul_dps ins(%2, %3 : memref<128x64xf16, strided<[64, 1], offset: ?>, #pto.address_space<left>>, memref<64x256xf16, strided<[256, 1], offset: ?>, #pto.address_space<right>>) outs(%4 : memref<128x256xf32, strided<[256, 1], offset: ?>, #pto.address_space<acc>>)
            scf.for %arg6 = %c1 to %12 step %c1 {
              %26 = arith.muli %arg6, %c64 : index
              %subview_8 = memref.subview %reinterpret_cast[0, 0, 0, %23, %26] [1, 1, 1, 128, 64] [1, 1, 1, 1, 1] : memref<?x?x?x?x?xf16, strided<[?, ?, ?, ?, ?], offset: ?>, #pto.address_space<gm>> to memref<1x1x1x128x64xf16, strided<[?, ?, ?, ?, ?], offset: ?>, #pto.address_space<gm>>
              pto.load_dps ins(%subview_8 : memref<1x1x1x128x64xf16, strided<[?, ?, ?, ?, ?], offset: ?>, #pto.address_space<gm>>) outs(%0 : memref<128x64xf16, strided<[64, 1], offset: ?>, #pto.address_space<mat>>)
              %27 = arith.addi %18, %26 : index
              %subview_9 = memref.subview %reinterpret_cast_0[0, 0, 0, %27, %25] [1, 1, 1, 64, 256] [1, 1, 1, 1, 1] : memref<?x?x?x?x?xf16, strided<[?, ?, ?, ?, ?], offset: ?>, #pto.address_space<gm>> to memref<1x1x1x64x256xf16, strided<[?, ?, ?, ?, ?], offset: ?>, #pto.address_space<gm>>
              pto.load_dps ins(%subview_9 : memref<1x1x1x64x256xf16, strided<[?, ?, ?, ?, ?], offset: ?>, #pto.address_space<gm>>) outs(%1 : memref<64x256xf16, strided<[256, 1], offset: ?>, #pto.address_space<mat>>)
              pto.mov_dps ins(%0 : memref<128x64xf16, strided<[64, 1], offset: ?>, #pto.address_space<mat>>) outs(%2 : memref<128x64xf16, strided<[64, 1], offset: ?>, #pto.address_space<left>>)
              pto.mov_dps ins(%1 : memref<64x256xf16, strided<[256, 1], offset: ?>, #pto.address_space<mat>>) outs(%3 : memref<64x256xf16, strided<[256, 1], offset: ?>, #pto.address_space<right>>)
              pto.matmul_acc_dps ins(%4, %2, %3 : memref<128x256xf32, strided<[256, 1], offset: ?>, #pto.address_space<acc>>, memref<128x64xf16, strided<[64, 1], offset: ?>, #pto.address_space<left>>, memref<64x256xf16, strided<[256, 1], offset: ?>, #pto.address_space<right>>) outs(%4 : memref<128x256xf32, strided<[256, 1], offset: ?>, #pto.address_space<acc>>)
            }
            %subview_7 = memref.subview %reinterpret_cast_1[0, 0, 0, %23, %25] [1, 1, 1, 128, 256] [1, 1, 1, 1, 1] : memref<?x?x?x?x?xf32, strided<[?, ?, ?, ?, ?], offset: ?>, #pto.address_space<gm>> to memref<1x1x1x128x256xf32, strided<[?, ?, ?, ?, ?], offset: ?>, #pto.address_space<gm>>
            pto.store_dps ins(%4 : memref<128x256xf32, strided<[256, 1], offset: ?>, #pto.address_space<acc>>) outs(%subview_7 : memref<1x1x1x128x256xf32, strided<[?, ?, ?, ?, ?], offset: ?>, #pto.address_space<gm>>)
          }
        }
      }
    }
    return
  }
}
end PTO plan Mem!
module attributes {"pto.device-spec" = "Ascend910B1"} {
  func.func @bgemm_kernel(%arg0: index, %arg1: memref<?xf16, #pto.address_space<gm>>, %arg2: memref<?xf16, #pto.address_space<gm>>, %arg3: memref<?xf32, #pto.address_space<gm>>) {
    %true = arith.constant true
    %c4 = arith.constant 4 : index
    %c2 = arith.constant 2 : index
    %c16384_i64 = arith.constant 16384 : i64
    %c0_i64 = arith.constant 0 : i64
    %c0 = arith.constant 0 : index
    %c64 = arith.constant 64 : index
    %c128 = arith.constant 128 : index
    %c1 = arith.constant 1 : index
    %c256 = arith.constant 256 : index
    %reinterpret_cast = memref.reinterpret_cast %arg1 to offset: [0], sizes: [%c1, %c1, %c1, %c256, %c256], strides: [%c1, %c1, %c1, %c256, %c1] : memref<?xf16, #pto.address_space<gm>> to memref<?x?x?x?x?xf16, strided<[?, ?, ?, ?, ?], offset: ?>, #pto.address_space<gm>>
    %reinterpret_cast_0 = memref.reinterpret_cast %arg2 to offset: [0], sizes: [%c1, %c1, %c1, %c256, %c256], strides: [%c1, %c1, %c1, %c1, %c256] : memref<?xf16, #pto.address_space<gm>> to memref<?x?x?x?x?xf16, strided<[?, ?, ?, ?, ?], offset: ?>, #pto.address_space<gm>>
    %reinterpret_cast_1 = memref.reinterpret_cast %arg3 to offset: [0], sizes: [%c1, %c1, %c1, %c256, %c256], strides: [%c1, %c1, %c1, %c256, %c1] : memref<?xf32, #pto.address_space<gm>> to memref<?x?x?x?x?xf32, strided<[?, ?, ?, ?, ?], offset: ?>, #pto.address_space<gm>>
    %0 = pto.pointer_cast(%c0_i64) : memref<128x64xf16, strided<[64, 1]>, #pto.address_space<mat>>
    %1 = pto.bind_tile %0 {config = #pto.tile_buf_config<blayout=1 : i32, slayout=1 : i32, s_fractal_size=512, pad=0 : i32>} : memref<128x64xf16, strided<[64, 1]>, #pto.address_space<mat>> -> memref<128x64xf16, strided<[64, 1], offset: ?>, #pto.address_space<mat>>
    %2 = pto.pointer_cast(%c16384_i64) : memref<64x256xf16, strided<[256, 1]>, #pto.address_space<mat>>
    %3 = pto.bind_tile %2 {config = #pto.tile_buf_config<blayout=0 : i32, slayout=2 : i32, s_fractal_size=512, pad=0 : i32>} : memref<64x256xf16, strided<[256, 1]>, #pto.address_space<mat>> -> memref<64x256xf16, strided<[256, 1], offset: ?>, #pto.address_space<mat>>
    %4 = pto.pointer_cast(%c0_i64) : memref<128x64xf16, strided<[64, 1]>, #pto.address_space<left>>
    %5 = pto.bind_tile %4 {config = #pto.tile_buf_config<blayout=0 : i32, slayout=1 : i32, s_fractal_size=512, pad=0 : i32>} : memref<128x64xf16, strided<[64, 1]>, #pto.address_space<left>> -> memref<128x64xf16, strided<[64, 1], offset: ?>, #pto.address_space<left>>
    %6 = pto.pointer_cast(%c0_i64) : memref<64x256xf16, strided<[256, 1]>, #pto.address_space<right>>
    %7 = pto.bind_tile %6 {config = #pto.tile_buf_config<blayout=0 : i32, slayout=2 : i32, s_fractal_size=512, pad=0 : i32>} : memref<64x256xf16, strided<[256, 1]>, #pto.address_space<right>> -> memref<64x256xf16, strided<[256, 1], offset: ?>, #pto.address_space<right>>
    %8 = pto.pointer_cast(%c0_i64) : memref<128x256xf32, strided<[256, 1]>, #pto.address_space<acc>>
    %9 = pto.bind_tile %8 {config = #pto.tile_buf_config<blayout=1 : i32, slayout=1 : i32, s_fractal_size=1024, pad=0 : i32>} : memref<128x256xf32, strided<[256, 1]>, #pto.address_space<acc>> -> memref<128x256xf32, strided<[256, 1], offset: ?>, #pto.address_space<acc>>
    %10 = arith.cmpi slt, %arg0, %c1 : index
    scf.if %10 {
      scf.if %true {
        %11 = arith.muli %arg0, %c256 : index
        %12 = arith.muli %arg0, %c256 : index
        scf.for %arg4 = %c0 to %c2 step %c1 {
          %13 = arith.muli %arg4, %c128 : index
          %14 = arith.addi %11, %13 : index
          scf.for %arg5 = %c0 to %c1 step %c1 {
            %15 = arith.muli %arg5, %c256 : index
            %subview = memref.subview %reinterpret_cast[0, 0, 0, %14, 0] [1, 1, 1, 128, 64] [1, 1, 1, 1, 1] : memref<?x?x?x?x?xf16, strided<[?, ?, ?, ?, ?], offset: ?>, #pto.address_space<gm>> to memref<1x1x1x128x64xf16, strided<[?, ?, ?, ?, ?], offset: ?>, #pto.address_space<gm>>
            pto.load_dps ins(%subview : memref<1x1x1x128x64xf16, strided<[?, ?, ?, ?, ?], offset: ?>, #pto.address_space<gm>>) outs(%1 : memref<128x64xf16, strided<[64, 1], offset: ?>, #pto.address_space<mat>>)
            %subview_2 = memref.subview %reinterpret_cast_0[0, 0, 0, %12, %15] [1, 1, 1, 64, 256] [1, 1, 1, 1, 1] : memref<?x?x?x?x?xf16, strided<[?, ?, ?, ?, ?], offset: ?>, #pto.address_space<gm>> to memref<1x1x1x64x256xf16, strided<[?, ?, ?, ?, ?], offset: ?>, #pto.address_space<gm>>
            pto.load_dps ins(%subview_2 : memref<1x1x1x64x256xf16, strided<[?, ?, ?, ?, ?], offset: ?>, #pto.address_space<gm>>) outs(%3 : memref<64x256xf16, strided<[256, 1], offset: ?>, #pto.address_space<mat>>)
            pto.mov_dps ins(%1 : memref<128x64xf16, strided<[64, 1], offset: ?>, #pto.address_space<mat>>) outs(%5 : memref<128x64xf16, strided<[64, 1], offset: ?>, #pto.address_space<left>>)
            pto.mov_dps ins(%3 : memref<64x256xf16, strided<[256, 1], offset: ?>, #pto.address_space<mat>>) outs(%7 : memref<64x256xf16, strided<[256, 1], offset: ?>, #pto.address_space<right>>)
            pto.matmul_dps ins(%5, %7 : memref<128x64xf16, strided<[64, 1], offset: ?>, #pto.address_space<left>>, memref<64x256xf16, strided<[256, 1], offset: ?>, #pto.address_space<right>>) outs(%9 : memref<128x256xf32, strided<[256, 1], offset: ?>, #pto.address_space<acc>>)
            scf.for %arg6 = %c1 to %c4 step %c1 {
              %16 = arith.muli %arg6, %c64 : index
              %subview_4 = memref.subview %reinterpret_cast[0, 0, 0, %14, %16] [1, 1, 1, 128, 64] [1, 1, 1, 1, 1] : memref<?x?x?x?x?xf16, strided<[?, ?, ?, ?, ?], offset: ?>, #pto.address_space<gm>> to memref<1x1x1x128x64xf16, strided<[?, ?, ?, ?, ?], offset: ?>, #pto.address_space<gm>>
              pto.load_dps ins(%subview_4 : memref<1x1x1x128x64xf16, strided<[?, ?, ?, ?, ?], offset: ?>, #pto.address_space<gm>>) outs(%1 : memref<128x64xf16, strided<[64, 1], offset: ?>, #pto.address_space<mat>>)
              %17 = arith.addi %12, %16 : index
              %subview_5 = memref.subview %reinterpret_cast_0[0, 0, 0, %17, %15] [1, 1, 1, 64, 256] [1, 1, 1, 1, 1] : memref<?x?x?x?x?xf16, strided<[?, ?, ?, ?, ?], offset: ?>, #pto.address_space<gm>> to memref<1x1x1x64x256xf16, strided<[?, ?, ?, ?, ?], offset: ?>, #pto.address_space<gm>>
              pto.load_dps ins(%subview_5 : memref<1x1x1x64x256xf16, strided<[?, ?, ?, ?, ?], offset: ?>, #pto.address_space<gm>>) outs(%3 : memref<64x256xf16, strided<[256, 1], offset: ?>, #pto.address_space<mat>>)
              pto.mov_dps ins(%1 : memref<128x64xf16, strided<[64, 1], offset: ?>, #pto.address_space<mat>>) outs(%5 : memref<128x64xf16, strided<[64, 1], offset: ?>, #pto.address_space<left>>)
              pto.mov_dps ins(%3 : memref<64x256xf16, strided<[256, 1], offset: ?>, #pto.address_space<mat>>) outs(%7 : memref<64x256xf16, strided<[256, 1], offset: ?>, #pto.address_space<right>>)
              pto.matmul_acc_dps ins(%9, %5, %7 : memref<128x256xf32, strided<[256, 1], offset: ?>, #pto.address_space<acc>>, memref<128x64xf16, strided<[64, 1], offset: ?>, #pto.address_space<left>>, memref<64x256xf16, strided<[256, 1], offset: ?>, #pto.address_space<right>>) outs(%9 : memref<128x256xf32, strided<[256, 1], offset: ?>, #pto.address_space<acc>>)
            }
            %subview_3 = memref.subview %reinterpret_cast_1[0, 0, 0, %14, %15] [1, 1, 1, 128, 256] [1, 1, 1, 1, 1] : memref<?x?x?x?x?xf32, strided<[?, ?, ?, ?, ?], offset: ?>, #pto.address_space<gm>> to memref<1x1x1x128x256xf32, strided<[?, ?, ?, ?, ?], offset: ?>, #pto.address_space<gm>>
            pto.store_dps ins(%9 : memref<128x256xf32, strided<[256, 1], offset: ?>, #pto.address_space<acc>>) outs(%subview_3 : memref<1x1x1x128x256xf32, strided<[?, ?, ?, ?, ?], offset: ?>, #pto.address_space<gm>>)
          }
        }
      }
    }
    return
  }
}

// === [PTOInsertSync] Start === //

[MemAnalyze] Analyzing Dependency:
  Now Node: pto.mov_dps
    DefVec (Size 1):
 - Root: arith.constant | Scope: 3
    UseVec (Size 1):
 - Root: arith.constant | Scope: 2
  Front Node: pto.load_dps
    DefVec (Size 1):
 - Root: arith.constant | Scope: 2
    UseVec (Size 1):
 - Root: BlockArg | Scope: 1

[DepBetween] Checking dependency...
  Vec A Size: 1
  Vec B Size: 1
  [MemAlias Check]
    Root A: OpResult defined by [arith.constant] | Type: i64
    Root B: OpResult defined by [arith.constant] | Type: i64
    Scope A: 2, Scope B: 2
  [Trace] GetRealRoot Start:
    Current: OpResult defined by [arith.constant] | Type: i64
    -> Hit Alloc/Other [arith.constant]. Stop.
  [Trace] GetRealRoot Start:
    Current: OpResult defined by [arith.constant] | Type: i64
    -> Hit Alloc/Other [arith.constant]. Stop.
    [Deep Check] Surface Roots differ. Digging deeper...
      Real Root A: OpResult defined by [arith.constant] | Type: i64
      Real Root B: OpResult defined by [arith.constant] | Type: i64
      -> Mismatch. Real roots differ.

[DepBetween] Checking dependency...
  Vec A Size: 1
  Vec B Size: 1
  [MemAlias Check]
    Root A: OpResult defined by [arith.constant] | Type: i64
    Root B: BlockArgument | Type: memref<?xf16, #pto.address_space<gm>>
    Scope A: 3, Scope B: 1
    -> Scope Mismatch. False.

[DepBetween] Checking dependency...
  Vec A Size: 1
  Vec B Size: 1
  [MemAlias Check]
    Root A: OpResult defined by [arith.constant] | Type: i64
    Root B: OpResult defined by [arith.constant] | Type: i64
    Scope A: 3, Scope B: 2
    -> Scope Mismatch. False.
  -> No Dependency.

[MemAnalyze] Analyzing Dependency:
  Now Node: pto.mov_dps
    DefVec (Size 1):
 - Root: arith.constant | Scope: 3
    UseVec (Size 1):
 - Root: arith.constant | Scope: 2
  Front Node: pto.load_dps
    DefVec (Size 1):
 - Root: arith.constant | Scope: 2
    UseVec (Size 1):
 - Root: BlockArg | Scope: 1

[DepBetween] Checking dependency...
  Vec A Size: 1
  Vec B Size: 1
  [MemAlias Check]
    Root A: OpResult defined by [arith.constant] | Type: i64
    Root B: OpResult defined by [arith.constant] | Type: i64
    Scope A: 2, Scope B: 2

[DepBetween] Checking dependency...
  Vec A Size: 1
  Vec B Size: 1
  [MemAlias Check]
    Root A: OpResult defined by [arith.constant] | Type: i64
    Root B: BlockArgument | Type: memref<?xf16, #pto.address_space<gm>>
    Scope A: 3, Scope B: 1
    -> Scope Mismatch. False.

[DepBetween] Checking dependency...
  Vec A Size: 1
  Vec B Size: 1
  [MemAlias Check]
    Root A: OpResult defined by [arith.constant] | Type: i64
    Root B: OpResult defined by [arith.constant] | Type: i64
    Scope A: 3, Scope B: 2
    -> Scope Mismatch. False.
  -> Dependency FOUND!
 [Trace Insert] SET_EVENT at Node 4 (POST)
 [Trace Insert] WAIT_EVENT at Node 6 (PRE)
 [Trace Record] Updating Record for Node 4, SetPipe=4

[MemAnalyze] Analyzing Dependency:
  Now Node: pto.mov_dps
    DefVec (Size 1):
 - Root: arith.constant | Scope: 4
    UseVec (Size 1):
 - Root: arith.constant | Scope: 2
  Front Node: pto.load_dps
    DefVec (Size 1):
 - Root: arith.constant | Scope: 2
    UseVec (Size 1):
 - Root: BlockArg | Scope: 1

[DepBetween] Checking dependency...
  Vec A Size: 1
  Vec B Size: 1
  [MemAlias Check]
    Root A: OpResult defined by [arith.constant] | Type: i64
    Root B: OpResult defined by [arith.constant] | Type: i64
    Scope A: 2, Scope B: 2

[DepBetween] Checking dependency...
  Vec A Size: 1
  Vec B Size: 1
  [MemAlias Check]
    Root A: OpResult defined by [arith.constant] | Type: i64
    Root B: BlockArgument | Type: memref<?xf16, #pto.address_space<gm>>
    Scope A: 4, Scope B: 1
    -> Scope Mismatch. False.

[DepBetween] Checking dependency...
  Vec A Size: 1
  Vec B Size: 1
  [MemAlias Check]
    Root A: OpResult defined by [arith.constant] | Type: i64
    Root B: OpResult defined by [arith.constant] | Type: i64
    Scope A: 4, Scope B: 2
    -> Scope Mismatch. False.
  -> Dependency FOUND!
 [Trace Insert] SET_EVENT at Node 5 (POST)
 [Trace Insert] WAIT_EVENT at Node 7 (PRE)
 [Trace Record] Updating Record for Node 5, SetPipe=4

[MemAnalyze] Analyzing Dependency:
  Now Node: pto.mov_dps
    DefVec (Size 1):
 - Root: arith.constant | Scope: 4
    UseVec (Size 1):
 - Root: arith.constant | Scope: 2
  Front Node: pto.load_dps
    DefVec (Size 1):
 - Root: arith.constant | Scope: 2
    UseVec (Size 1):
 - Root: BlockArg | Scope: 1
  -> Already Synced at Pipe Level. Skipping.

[MemAnalyze] Analyzing Dependency:
  Now Node: pto.matmul_dps
    DefVec (Size 1):
 - Root: arith.constant | Scope: 5
    UseVec (Size 2):
 - Root: arith.constant | Scope: 3
 - Root: arith.constant | Scope: 4
  Front Node: pto.mov_dps
    DefVec (Size 1):
 - Root: arith.constant | Scope: 4
    UseVec (Size 1):
 - Root: arith.constant | Scope: 2

[DepBetween] Checking dependency...
  Vec A Size: 2
  Vec B Size: 1
  [MemAlias Check]
    Root A: OpResult defined by [arith.constant] | Type: i64
    Root B: OpResult defined by [arith.constant] | Type: i64
    Scope A: 3, Scope B: 4
    -> Scope Mismatch. False.
  [MemAlias Check]
    Root A: OpResult defined by [arith.constant] | Type: i64
    Root B: OpResult defined by [arith.constant] | Type: i64
    Scope A: 4, Scope B: 4

[DepBetween] Checking dependency...
  Vec A Size: 1
  Vec B Size: 1
  [MemAlias Check]
    Root A: OpResult defined by [arith.constant] | Type: i64
    Root B: OpResult defined by [arith.constant] | Type: i64
    Scope A: 5, Scope B: 2
    -> Scope Mismatch. False.

[DepBetween] Checking dependency...
  Vec A Size: 1
  Vec B Size: 1
  [MemAlias Check]
    Root A: OpResult defined by [arith.constant] | Type: i64
    Root B: OpResult defined by [arith.constant] | Type: i64
    Scope A: 5, Scope B: 4
    -> Scope Mismatch. False.
  -> Dependency FOUND!
 [Trace Insert] SET_EVENT at Node 7 (POST)
 [Trace Insert] WAIT_EVENT at Node 8 (PRE)
 [Trace Record] Updating Record for Node 7, SetPipe=3

[MemAnalyze] Analyzing Dependency:
  Now Node: pto.matmul_dps
    DefVec (Size 1):
 - Root: arith.constant | Scope: 5
    UseVec (Size 2):
 - Root: arith.constant | Scope: 3
 - Root: arith.constant | Scope: 4
  Front Node: pto.mov_dps
    DefVec (Size 1):
 - Root: arith.constant | Scope: 3
    UseVec (Size 1):
 - Root: arith.constant | Scope: 2

[DepBetween] Checking dependency...
  Vec A Size: 2
  Vec B Size: 1
  [MemAlias Check]
    Root A: OpResult defined by [arith.constant] | Type: i64
    Root B: OpResult defined by [arith.constant] | Type: i64
    Scope A: 3, Scope B: 3
  [MemAlias Check]
    Root A: OpResult defined by [arith.constant] | Type: i64
    Root B: OpResult defined by [arith.constant] | Type: i64
    Scope A: 4, Scope B: 3
    -> Scope Mismatch. False.

[DepBetween] Checking dependency...
  Vec A Size: 1
  Vec B Size: 1
  [MemAlias Check]
    Root A: OpResult defined by [arith.constant] | Type: i64
    Root B: OpResult defined by [arith.constant] | Type: i64
    Scope A: 5, Scope B: 2
    -> Scope Mismatch. False.

[DepBetween] Checking dependency...
  Vec A Size: 1
  Vec B Size: 1
  [MemAlias Check]
    Root A: OpResult defined by [arith.constant] | Type: i64
    Root B: OpResult defined by [arith.constant] | Type: i64
    Scope A: 5, Scope B: 3
    -> Scope Mismatch. False.
  -> Dependency FOUND!
 [Trace Insert] SET_EVENT at Node 6 (POST)
 [Trace Insert] WAIT_EVENT at Node 8 (PRE)
 [Trace Record] Updating Record for Node 6, SetPipe=3

[MemAnalyze] Analyzing Dependency:
  Now Node: pto.matmul_dps
    DefVec (Size 1):
 - Root: arith.constant | Scope: 5
    UseVec (Size 2):
 - Root: arith.constant | Scope: 3
 - Root: arith.constant | Scope: 4
  Front Node: pto.load_dps
    DefVec (Size 1):
 - Root: arith.constant | Scope: 2
    UseVec (Size 1):
 - Root: BlockArg | Scope: 1

[DepBetween] Checking dependency...
  Vec A Size: 2
  Vec B Size: 1
  [MemAlias Check]
    Root A: OpResult defined by [arith.constant] | Type: i64
    Root B: OpResult defined by [arith.constant] | Type: i64
    Scope A: 3, Scope B: 2
    -> Scope Mismatch. False.
  [MemAlias Check]
    Root A: OpResult defined by [arith.constant] | Type: i64
    Root B: OpResult defined by [arith.constant] | Type: i64
    Scope A: 4, Scope B: 2
    -> Scope Mismatch. False.

[DepBetween] Checking dependency...
  Vec A Size: 1
  Vec B Size: 1
  [MemAlias Check]
    Root A: OpResult defined by [arith.constant] | Type: i64
    Root B: BlockArgument | Type: memref<?xf16, #pto.address_space<gm>>
    Scope A: 5, Scope B: 1
    -> Scope Mismatch. False.

[DepBetween] Checking dependency...
  Vec A Size: 1
  Vec B Size: 1
  [MemAlias Check]
    Root A: OpResult defined by [arith.constant] | Type: i64
    Root B: OpResult defined by [arith.constant] | Type: i64
    Scope A: 5, Scope B: 2
    -> Scope Mismatch. False.
  -> No Dependency.

[MemAnalyze] Analyzing Dependency:
  Now Node: pto.matmul_dps
    DefVec (Size 1):
 - Root: arith.constant | Scope: 5
    UseVec (Size 2):
 - Root: arith.constant | Scope: 3
 - Root: arith.constant | Scope: 4
  Front Node: pto.load_dps
    DefVec (Size 1):
 - Root: arith.constant | Scope: 2
    UseVec (Size 1):
 - Root: BlockArg | Scope: 1

[DepBetween] Checking dependency...
  Vec A Size: 2
  Vec B Size: 1
  [MemAlias Check]
    Root A: OpResult defined by [arith.constant] | Type: i64
    Root B: OpResult defined by [arith.constant] | Type: i64
    Scope A: 3, Scope B: 2
    -> Scope Mismatch. False.
  [MemAlias Check]
    Root A: OpResult defined by [arith.constant] | Type: i64
    Root B: OpResult defined by [arith.constant] | Type: i64
    Scope A: 4, Scope B: 2
    -> Scope Mismatch. False.

[DepBetween] Checking dependency...
  Vec A Size: 1
  Vec B Size: 1
  [MemAlias Check]
    Root A: OpResult defined by [arith.constant] | Type: i64
    Root B: BlockArgument | Type: memref<?xf16, #pto.address_space<gm>>
    Scope A: 5, Scope B: 1
    -> Scope Mismatch. False.

[DepBetween] Checking dependency...
  Vec A Size: 1
  Vec B Size: 1
  [MemAlias Check]
    Root A: OpResult defined by [arith.constant] | Type: i64
    Root B: OpResult defined by [arith.constant] | Type: i64
    Scope A: 5, Scope B: 2
    -> Scope Mismatch. False.
  -> No Dependency.

[MemAnalyze] Analyzing Dependency:
  Now Node: pto.load_dps
    DefVec (Size 1):
 - Root: arith.constant | Scope: 2
    UseVec (Size 1):
 - Root: BlockArg | Scope: 1
  Front Node: pto.matmul_dps
    DefVec (Size 1):
 - Root: arith.constant | Scope: 5
    UseVec (Size 2):
 - Root: arith.constant | Scope: 3
 - Root: arith.constant | Scope: 4

[DepBetween] Checking dependency...
  Vec A Size: 1
  Vec B Size: 1
  [MemAlias Check]
    Root A: BlockArgument | Type: memref<?xf16, #pto.address_space<gm>>
    Root B: OpResult defined by [arith.constant] | Type: i64
    Scope A: 1, Scope B: 5
    -> Scope Mismatch. False.

[DepBetween] Checking dependency...
  Vec A Size: 1
  Vec B Size: 2
  [MemAlias Check]
    Root A: OpResult defined by [arith.constant] | Type: i64
    Root B: OpResult defined by [arith.constant] | Type: i64
    Scope A: 2, Scope B: 3
    -> Scope Mismatch. False.
  [MemAlias Check]
    Root A: OpResult defined by [arith.constant] | Type: i64
    Root B: OpResult defined by [arith.constant] | Type: i64
    Scope A: 2, Scope B: 4
    -> Scope Mismatch. False.

[DepBetween] Checking dependency...
  Vec A Size: 1
  Vec B Size: 1
  [MemAlias Check]
    Root A: OpResult defined by [arith.constant] | Type: i64
    Root B: OpResult defined by [arith.constant] | Type: i64
    Scope A: 2, Scope B: 5
    -> Scope Mismatch. False.
  -> No Dependency.

[MemAnalyze] Analyzing Dependency:
  Now Node: pto.load_dps
    DefVec (Size 1):
 - Root: arith.constant | Scope: 2
    UseVec (Size 1):
 - Root: BlockArg | Scope: 1
  Front Node: pto.mov_dps
    DefVec (Size 1):
 - Root: arith.constant | Scope: 4
    UseVec (Size 1):
 - Root: arith.constant | Scope: 2

[DepBetween] Checking dependency...
  Vec A Size: 1
  Vec B Size: 1
  [MemAlias Check]
    Root A: BlockArgument | Type: memref<?xf16, #pto.address_space<gm>>
    Root B: OpResult defined by [arith.constant] | Type: i64
    Scope A: 1, Scope B: 4
    -> Scope Mismatch. False.

[DepBetween] Checking dependency...
  Vec A Size: 1
  Vec B Size: 1
  [MemAlias Check]
    Root A: OpResult defined by [arith.constant] | Type: i64
    Root B: OpResult defined by [arith.constant] | Type: i64
    Scope A: 2, Scope B: 2
  [Trace] GetRealRoot Start:
    Current: OpResult defined by [arith.constant] | Type: i64
    -> Hit Alloc/Other [arith.constant]. Stop.
  [Trace] GetRealRoot Start:
    Current: OpResult defined by [arith.constant] | Type: i64
    -> Hit Alloc/Other [arith.constant]. Stop.
    [Deep Check] Surface Roots differ. Digging deeper...
      Real Root A: OpResult defined by [arith.constant] | Type: i64
      Real Root B: OpResult defined by [arith.constant] | Type: i64
      -> Mismatch. Real roots differ.

[DepBetween] Checking dependency...
  Vec A Size: 1
  Vec B Size: 1
  [MemAlias Check]
    Root A: OpResult defined by [arith.constant] | Type: i64
    Root B: OpResult defined by [arith.constant] | Type: i64
    Scope A: 2, Scope B: 4
    -> Scope Mismatch. False.
  -> No Dependency.

[MemAnalyze] Analyzing Dependency:
  Now Node: pto.load_dps
    DefVec (Size 1):
 - Root: arith.constant | Scope: 2
    UseVec (Size 1):
 - Root: BlockArg | Scope: 1
  Front Node: pto.mov_dps
    DefVec (Size 1):
 - Root: arith.constant | Scope: 3
    UseVec (Size 1):
 - Root: arith.constant | Scope: 2

[DepBetween] Checking dependency...
  Vec A Size: 1
  Vec B Size: 1
  [MemAlias Check]
    Root A: BlockArgument | Type: memref<?xf16, #pto.address_space<gm>>
    Root B: OpResult defined by [arith.constant] | Type: i64
    Scope A: 1, Scope B: 3
    -> Scope Mismatch. False.

[DepBetween] Checking dependency...
  Vec A Size: 1
  Vec B Size: 1
  [MemAlias Check]
    Root A: OpResult defined by [arith.constant] | Type: i64
    Root B: OpResult defined by [arith.constant] | Type: i64
    Scope A: 2, Scope B: 2

[DepBetween] Checking dependency...
  Vec A Size: 1
  Vec B Size: 1
  [MemAlias Check]
    Root A: OpResult defined by [arith.constant] | Type: i64
    Root B: OpResult defined by [arith.constant] | Type: i64
    Scope A: 2, Scope B: 3
    -> Scope Mismatch. False.
  -> Dependency FOUND!
 [Trace Insert] SET_EVENT at Node 6 (POST)
 [Trace Insert] WAIT_EVENT at Node 10 (PRE)
 [Trace Record] Updating Record for Node 6, SetPipe=3

[MemAnalyze] Analyzing Dependency:
  Now Node: pto.load_dps
    DefVec (Size 1):
 - Root: arith.constant | Scope: 2
    UseVec (Size 1):
 - Root: BlockArg | Scope: 1
  Front Node: pto.matmul_dps
    DefVec (Size 1):
 - Root: arith.constant | Scope: 5
    UseVec (Size 2):
 - Root: arith.constant | Scope: 3
 - Root: arith.constant | Scope: 4

[DepBetween] Checking dependency...
  Vec A Size: 1
  Vec B Size: 1
  [MemAlias Check]
    Root A: BlockArgument | Type: memref<?xf16, #pto.address_space<gm>>
    Root B: OpResult defined by [arith.constant] | Type: i64
    Scope A: 1, Scope B: 5
    -> Scope Mismatch. False.

[DepBetween] Checking dependency...
  Vec A Size: 1
  Vec B Size: 2
  [MemAlias Check]
    Root A: OpResult defined by [arith.constant] | Type: i64
    Root B: OpResult defined by [arith.constant] | Type: i64
    Scope A: 2, Scope B: 3
    -> Scope Mismatch. False.
  [MemAlias Check]
    Root A: OpResult defined by [arith.constant] | Type: i64
    Root B: OpResult defined by [arith.constant] | Type: i64
    Scope A: 2, Scope B: 4
    -> Scope Mismatch. False.

[DepBetween] Checking dependency...
  Vec A Size: 1
  Vec B Size: 1
  [MemAlias Check]
    Root A: OpResult defined by [arith.constant] | Type: i64
    Root B: OpResult defined by [arith.constant] | Type: i64
    Scope A: 2, Scope B: 5
    -> Scope Mismatch. False.
  -> No Dependency.

[MemAnalyze] Analyzing Dependency:
  Now Node: pto.load_dps
    DefVec (Size 1):
 - Root: arith.constant | Scope: 2
    UseVec (Size 1):
 - Root: BlockArg | Scope: 1
  Front Node: pto.mov_dps
    DefVec (Size 1):
 - Root: arith.constant | Scope: 4
    UseVec (Size 1):
 - Root: arith.constant | Scope: 2

[DepBetween] Checking dependency...
  Vec A Size: 1
  Vec B Size: 1
  [MemAlias Check]
    Root A: BlockArgument | Type: memref<?xf16, #pto.address_space<gm>>
    Root B: OpResult defined by [arith.constant] | Type: i64
    Scope A: 1, Scope B: 4
    -> Scope Mismatch. False.

[DepBetween] Checking dependency...
  Vec A Size: 1
  Vec B Size: 1
  [MemAlias Check]
    Root A: OpResult defined by [arith.constant] | Type: i64
    Root B: OpResult defined by [arith.constant] | Type: i64
    Scope A: 2, Scope B: 2

[DepBetween] Checking dependency...
  Vec A Size: 1
  Vec B Size: 1
  [MemAlias Check]
    Root A: OpResult defined by [arith.constant] | Type: i64
    Root B: OpResult defined by [arith.constant] | Type: i64
    Scope A: 2, Scope B: 4
    -> Scope Mismatch. False.
  -> Dependency FOUND!
 [Trace Insert] SET_EVENT at Node 7 (POST)
 [Trace Insert] WAIT_EVENT at Node 11 (PRE)
 [Trace Record] Updating Record for Node 7, SetPipe=3

[MemAnalyze] Analyzing Dependency:
  Now Node: pto.load_dps
    DefVec (Size 1):
 - Root: arith.constant | Scope: 2
    UseVec (Size 1):
 - Root: BlockArg | Scope: 1
  Front Node: pto.mov_dps
    DefVec (Size 1):
 - Root: arith.constant | Scope: 3
    UseVec (Size 1):
 - Root: arith.constant | Scope: 2
  -> Already Synced at Pipe Level. Skipping.

[MemAnalyze] Analyzing Dependency:
  Now Node: pto.mov_dps
    DefVec (Size 1):
 - Root: arith.constant | Scope: 3
    UseVec (Size 1):
 - Root: arith.constant | Scope: 2
  Front Node: pto.load_dps
    DefVec (Size 1):
 - Root: arith.constant | Scope: 2
    UseVec (Size 1):
 - Root: BlockArg | Scope: 1

[DepBetween] Checking dependency...
  Vec A Size: 1
  Vec B Size: 1
  [MemAlias Check]
    Root A: OpResult defined by [arith.constant] | Type: i64
    Root B: OpResult defined by [arith.constant] | Type: i64
    Scope A: 2, Scope B: 2
  [Trace] GetRealRoot Start:
    Current: OpResult defined by [arith.constant] | Type: i64
    -> Hit Alloc/Other [arith.constant]. Stop.
  [Trace] GetRealRoot Start:
    Current: OpResult defined by [arith.constant] | Type: i64
    -> Hit Alloc/Other [arith.constant]. Stop.
    [Deep Check] Surface Roots differ. Digging deeper...
      Real Root A: OpResult defined by [arith.constant] | Type: i64
      Real Root B: OpResult defined by [arith.constant] | Type: i64
      -> Mismatch. Real roots differ.

[DepBetween] Checking dependency...
  Vec A Size: 1
  Vec B Size: 1
  [MemAlias Check]
    Root A: OpResult defined by [arith.constant] | Type: i64
    Root B: BlockArgument | Type: memref<?xf16, #pto.address_space<gm>>
    Scope A: 3, Scope B: 1
    -> Scope Mismatch. False.

[DepBetween] Checking dependency...
  Vec A Size: 1
  Vec B Size: 1
  [MemAlias Check]
    Root A: OpResult defined by [arith.constant] | Type: i64
    Root B: OpResult defined by [arith.constant] | Type: i64
    Scope A: 3, Scope B: 2
    -> Scope Mismatch. False.
  -> No Dependency.

[MemAnalyze] Analyzing Dependency:
  Now Node: pto.mov_dps
    DefVec (Size 1):
 - Root: arith.constant | Scope: 3
    UseVec (Size 1):
 - Root: arith.constant | Scope: 2
  Front Node: pto.load_dps
    DefVec (Size 1):
 - Root: arith.constant | Scope: 2
    UseVec (Size 1):
 - Root: BlockArg | Scope: 1

[DepBetween] Checking dependency...
  Vec A Size: 1
  Vec B Size: 1
  [MemAlias Check]
    Root A: OpResult defined by [arith.constant] | Type: i64
    Root B: OpResult defined by [arith.constant] | Type: i64
    Scope A: 2, Scope B: 2

[DepBetween] Checking dependency...
  Vec A Size: 1
  Vec B Size: 1
  [MemAlias Check]
    Root A: OpResult defined by [arith.constant] | Type: i64
    Root B: BlockArgument | Type: memref<?xf16, #pto.address_space<gm>>
    Scope A: 3, Scope B: 1
    -> Scope Mismatch. False.

[DepBetween] Checking dependency...
  Vec A Size: 1
  Vec B Size: 1
  [MemAlias Check]
    Root A: OpResult defined by [arith.constant] | Type: i64
    Root B: OpResult defined by [arith.constant] | Type: i64
    Scope A: 3, Scope B: 2
    -> Scope Mismatch. False.
  -> Dependency FOUND!
 [Trace Insert] SET_EVENT at Node 10 (POST)
 [Trace Insert] WAIT_EVENT at Node 12 (PRE)
 [Trace Record] Updating Record for Node 10, SetPipe=4

[MemAnalyze] Analyzing Dependency:
  Now Node: pto.mov_dps
    DefVec (Size 1):
 - Root: arith.constant | Scope: 3
    UseVec (Size 1):
 - Root: arith.constant | Scope: 2
  Front Node: pto.matmul_dps
    DefVec (Size 1):
 - Root: arith.constant | Scope: 5
    UseVec (Size 2):
 - Root: arith.constant | Scope: 3
 - Root: arith.constant | Scope: 4

[DepBetween] Checking dependency...
  Vec A Size: 1
  Vec B Size: 1
  [MemAlias Check]
    Root A: OpResult defined by [arith.constant] | Type: i64
    Root B: OpResult defined by [arith.constant] | Type: i64
    Scope A: 2, Scope B: 5
    -> Scope Mismatch. False.

[DepBetween] Checking dependency...
  Vec A Size: 1
  Vec B Size: 2
  [MemAlias Check]
    Root A: OpResult defined by [arith.constant] | Type: i64
    Root B: OpResult defined by [arith.constant] | Type: i64
    Scope A: 3, Scope B: 3
  [MemAlias Check]
    Root A: OpResult defined by [arith.constant] | Type: i64
    Root B: OpResult defined by [arith.constant] | Type: i64
    Scope A: 3, Scope B: 4
    -> Scope Mismatch. False.

[DepBetween] Checking dependency...
  Vec A Size: 1
  Vec B Size: 1
  [MemAlias Check]
    Root A: OpResult defined by [arith.constant] | Type: i64
    Root B: OpResult defined by [arith.constant] | Type: i64
    Scope A: 3, Scope B: 5
    -> Scope Mismatch. False.
  -> Dependency FOUND!
 [Trace Insert] SET_EVENT at Node 8 (POST)
 [Trace Insert] WAIT_EVENT at Node 12 (PRE)
 [Trace Record] Updating Record for Node 8, SetPipe=2

[MemAnalyze] Analyzing Dependency:
  Now Node: pto.mov_dps
    DefVec (Size 1):
 - Root: arith.constant | Scope: 3
    UseVec (Size 1):
 - Root: arith.constant | Scope: 2
  Front Node: pto.load_dps
    DefVec (Size 1):
 - Root: arith.constant | Scope: 2
    UseVec (Size 1):
 - Root: BlockArg | Scope: 1
  -> Already Synced at Pipe Level. Skipping.

[MemAnalyze] Analyzing Dependency:
  Now Node: pto.mov_dps
    DefVec (Size 1):
 - Root: arith.constant | Scope: 3
    UseVec (Size 1):
 - Root: arith.constant | Scope: 2
  Front Node: pto.load_dps
    DefVec (Size 1):
 - Root: arith.constant | Scope: 2
    UseVec (Size 1):
 - Root: BlockArg | Scope: 1
  -> Already Synced at Pipe Level. Skipping.

[MemAnalyze] Analyzing Dependency:
  Now Node: pto.mov_dps
    DefVec (Size 1):
 - Root: arith.constant | Scope: 4
    UseVec (Size 1):
 - Root: arith.constant | Scope: 2
  Front Node: pto.load_dps
    DefVec (Size 1):
 - Root: arith.constant | Scope: 2
    UseVec (Size 1):
 - Root: BlockArg | Scope: 1

[DepBetween] Checking dependency...
  Vec A Size: 1
  Vec B Size: 1
  [MemAlias Check]
    Root A: OpResult defined by [arith.constant] | Type: i64
    Root B: OpResult defined by [arith.constant] | Type: i64
    Scope A: 2, Scope B: 2

[DepBetween] Checking dependency...
  Vec A Size: 1
  Vec B Size: 1
  [MemAlias Check]
    Root A: OpResult defined by [arith.constant] | Type: i64
    Root B: BlockArgument | Type: memref<?xf16, #pto.address_space<gm>>
    Scope A: 4, Scope B: 1
    -> Scope Mismatch. False.

[DepBetween] Checking dependency...
  Vec A Size: 1
  Vec B Size: 1
  [MemAlias Check]
    Root A: OpResult defined by [arith.constant] | Type: i64
    Root B: OpResult defined by [arith.constant] | Type: i64
    Scope A: 4, Scope B: 2
    -> Scope Mismatch. False.
  -> Dependency FOUND!
 [Trace Insert] SET_EVENT at Node 11 (POST)
 [Trace Insert] WAIT_EVENT at Node 13 (PRE)
 [Trace Record] Updating Record for Node 11, SetPipe=4

[MemAnalyze] Analyzing Dependency:
  Now Node: pto.mov_dps
    DefVec (Size 1):
 - Root: arith.constant | Scope: 4
    UseVec (Size 1):
 - Root: arith.constant | Scope: 2
  Front Node: pto.load_dps
    DefVec (Size 1):
 - Root: arith.constant | Scope: 2
    UseVec (Size 1):
 - Root: BlockArg | Scope: 1
  -> Already Synced at Pipe Level. Skipping.

[MemAnalyze] Analyzing Dependency:
  Now Node: pto.mov_dps
    DefVec (Size 1):
 - Root: arith.constant | Scope: 4
    UseVec (Size 1):
 - Root: arith.constant | Scope: 2
  Front Node: pto.matmul_dps
    DefVec (Size 1):
 - Root: arith.constant | Scope: 5
    UseVec (Size 2):
 - Root: arith.constant | Scope: 3
 - Root: arith.constant | Scope: 4
  -> Already Synced at Pipe Level. Skipping.

[MemAnalyze] Analyzing Dependency:
  Now Node: pto.mov_dps
    DefVec (Size 1):
 - Root: arith.constant | Scope: 4
    UseVec (Size 1):
 - Root: arith.constant | Scope: 2
  Front Node: pto.load_dps
    DefVec (Size 1):
 - Root: arith.constant | Scope: 2
    UseVec (Size 1):
 - Root: BlockArg | Scope: 1
  -> Already Synced at Pipe Level. Skipping.

[MemAnalyze] Analyzing Dependency:
  Now Node: pto.mov_dps
    DefVec (Size 1):
 - Root: arith.constant | Scope: 4
    UseVec (Size 1):
 - Root: arith.constant | Scope: 2
  Front Node: pto.load_dps
    DefVec (Size 1):
 - Root: arith.constant | Scope: 2
    UseVec (Size 1):
 - Root: BlockArg | Scope: 1
  -> Already Synced at Pipe Level. Skipping.

[MemAnalyze] Analyzing Dependency:
  Now Node: pto.load_dps
    DefVec (Size 1):
 - Root: arith.constant | Scope: 2
    UseVec (Size 1):
 - Root: BlockArg | Scope: 1
  Front Node: pto.mov_dps
    DefVec (Size 1):
 - Root: arith.constant | Scope: 4
    UseVec (Size 1):
 - Root: arith.constant | Scope: 2

[DepBetween] Checking dependency...
  Vec A Size: 1
  Vec B Size: 1
  [MemAlias Check]
    Root A: BlockArgument | Type: memref<?xf16, #pto.address_space<gm>>
    Root B: OpResult defined by [arith.constant] | Type: i64
    Scope A: 1, Scope B: 4
    -> Scope Mismatch. False.

[DepBetween] Checking dependency...
  Vec A Size: 1
  Vec B Size: 1
  [MemAlias Check]
    Root A: OpResult defined by [arith.constant] | Type: i64
    Root B: OpResult defined by [arith.constant] | Type: i64
    Scope A: 2, Scope B: 2
  [Trace] GetRealRoot Start:
    Current: OpResult defined by [arith.constant] | Type: i64
    -> Hit Alloc/Other [arith.constant]. Stop.
  [Trace] GetRealRoot Start:
    Current: OpResult defined by [arith.constant] | Type: i64
    -> Hit Alloc/Other [arith.constant]. Stop.
    [Deep Check] Surface Roots differ. Digging deeper...
      Real Root A: OpResult defined by [arith.constant] | Type: i64
      Real Root B: OpResult defined by [arith.constant] | Type: i64
      -> Mismatch. Real roots differ.

[DepBetween] Checking dependency...
  Vec A Size: 1
  Vec B Size: 1
  [MemAlias Check]
    Root A: OpResult defined by [arith.constant] | Type: i64
    Root B: OpResult defined by [arith.constant] | Type: i64
    Scope A: 2, Scope B: 4
    -> Scope Mismatch. False.
  -> No Dependency.

[MemAnalyze] Analyzing Dependency:
  Now Node: pto.load_dps
    DefVec (Size 1):
 - Root: arith.constant | Scope: 2
    UseVec (Size 1):
 - Root: BlockArg | Scope: 1
  Front Node: pto.mov_dps
    DefVec (Size 1):
 - Root: arith.constant | Scope: 3
    UseVec (Size 1):
 - Root: arith.constant | Scope: 2

[DepBetween] Checking dependency...
  Vec A Size: 1
  Vec B Size: 1
  [MemAlias Check]
    Root A: BlockArgument | Type: memref<?xf16, #pto.address_space<gm>>
    Root B: OpResult defined by [arith.constant] | Type: i64
    Scope A: 1, Scope B: 3
    -> Scope Mismatch. False.

[DepBetween] Checking dependency...
  Vec A Size: 1
  Vec B Size: 1
  [MemAlias Check]
    Root A: OpResult defined by [arith.constant] | Type: i64
    Root B: OpResult defined by [arith.constant] | Type: i64
    Scope A: 2, Scope B: 2

[DepBetween] Checking dependency...
  Vec A Size: 1
  Vec B Size: 1
  [MemAlias Check]
    Root A: OpResult defined by [arith.constant] | Type: i64
    Root B: OpResult defined by [arith.constant] | Type: i64
    Scope A: 2, Scope B: 3
    -> Scope Mismatch. False.
  -> Dependency FOUND!
 [Trace Insert] SET_EVENT at Node 12 (POST)
 [Trace Insert] WAIT_EVENT at Node 10 (PRE)
 [Trace Record] Updating Record for Node 12, SetPipe=3

[MemAnalyze] Analyzing Dependency:
  Now Node: pto.load_dps
    DefVec (Size 1):
 - Root: arith.constant | Scope: 2
    UseVec (Size 1):
 - Root: BlockArg | Scope: 1
  Front Node: pto.load_dps
    DefVec (Size 1):
 - Root: arith.constant | Scope: 2
    UseVec (Size 1):
 - Root: BlockArg | Scope: 1

[DepBetween] Checking dependency...
  Vec A Size: 1
  Vec B Size: 1
  [MemAlias Check]
    Root A: BlockArgument | Type: memref<?xf16, #pto.address_space<gm>>
    Root B: OpResult defined by [arith.constant] | Type: i64
    Scope A: 1, Scope B: 2
    -> Scope Mismatch. False.

[DepBetween] Checking dependency...
  Vec A Size: 1
  Vec B Size: 1
  [MemAlias Check]
    Root A: OpResult defined by [arith.constant] | Type: i64
    Root B: BlockArgument | Type: memref<?xf16, #pto.address_space<gm>>
    Scope A: 2, Scope B: 1
    -> Scope Mismatch. False.

[DepBetween] Checking dependency...
  Vec A Size: 1
  Vec B Size: 1
  [MemAlias Check]
    Root A: OpResult defined by [arith.constant] | Type: i64
    Root B: OpResult defined by [arith.constant] | Type: i64
    Scope A: 2, Scope B: 2
  [Trace] GetRealRoot Start:
    Current: OpResult defined by [arith.constant] | Type: i64
    -> Hit Alloc/Other [arith.constant]. Stop.
  [Trace] GetRealRoot Start:
    Current: OpResult defined by [arith.constant] | Type: i64
    -> Hit Alloc/Other [arith.constant]. Stop.
    [Deep Check] Surface Roots differ. Digging deeper...
      Real Root A: OpResult defined by [arith.constant] | Type: i64
      Real Root B: OpResult defined by [arith.constant] | Type: i64
      -> Mismatch. Real roots differ.
  -> No Dependency.

[MemAnalyze] Analyzing Dependency:
  Now Node: pto.load_dps
    DefVec (Size 1):
 - Root: arith.constant | Scope: 2
    UseVec (Size 1):
 - Root: BlockArg | Scope: 1
  Front Node: pto.load_dps
    DefVec (Size 1):
 - Root: arith.constant | Scope: 2
    UseVec (Size 1):
 - Root: BlockArg | Scope: 1

[DepBetween] Checking dependency...
  Vec A Size: 1
  Vec B Size: 1
  [MemAlias Check]
    Root A: BlockArgument | Type: memref<?xf16, #pto.address_space<gm>>
    Root B: OpResult defined by [arith.constant] | Type: i64
    Scope A: 1, Scope B: 2
    -> Scope Mismatch. False.

[DepBetween] Checking dependency...
  Vec A Size: 1
  Vec B Size: 1
  [MemAlias Check]
    Root A: OpResult defined by [arith.constant] | Type: i64
    Root B: BlockArgument | Type: memref<?xf16, #pto.address_space<gm>>
    Scope A: 2, Scope B: 1
    -> Scope Mismatch. False.

[DepBetween] Checking dependency...
  Vec A Size: 1
  Vec B Size: 1
  [MemAlias Check]
    Root A: OpResult defined by [arith.constant] | Type: i64
    Root B: OpResult defined by [arith.constant] | Type: i64
    Scope A: 2, Scope B: 2
  -> Dependency FOUND!
  -> Intra-Pipe dep on Local Mem (No GM). Skipping Barrier.

[MemAnalyze] Analyzing Dependency:
  Now Node: pto.load_dps
    DefVec (Size 1):
 - Root: arith.constant | Scope: 2
    UseVec (Size 1):
 - Root: BlockArg | Scope: 1
  Front Node: pto.mov_dps
    DefVec (Size 1):
 - Root: arith.constant | Scope: 4
    UseVec (Size 1):
 - Root: arith.constant | Scope: 2

[DepBetween] Checking dependency...
  Vec A Size: 1
  Vec B Size: 1
  [MemAlias Check]
    Root A: BlockArgument | Type: memref<?xf16, #pto.address_space<gm>>
    Root B: OpResult defined by [arith.constant] | Type: i64
    Scope A: 1, Scope B: 4
    -> Scope Mismatch. False.

[DepBetween] Checking dependency...
  Vec A Size: 1
  Vec B Size: 1
  [MemAlias Check]
    Root A: OpResult defined by [arith.constant] | Type: i64
    Root B: OpResult defined by [arith.constant] | Type: i64
    Scope A: 2, Scope B: 2

[DepBetween] Checking dependency...
  Vec A Size: 1
  Vec B Size: 1
  [MemAlias Check]
    Root A: OpResult defined by [arith.constant] | Type: i64
    Root B: OpResult defined by [arith.constant] | Type: i64
    Scope A: 2, Scope B: 4
    -> Scope Mismatch. False.
  -> Dependency FOUND!
 [Trace Insert] SET_EVENT at Node 13 (POST)
 [Trace Insert] WAIT_EVENT at Node 11 (PRE)
 [Trace Record] Updating Record for Node 13, SetPipe=3

[MemAnalyze] Analyzing Dependency:
  Now Node: pto.load_dps
    DefVec (Size 1):
 - Root: arith.constant | Scope: 2
    UseVec (Size 1):
 - Root: BlockArg | Scope: 1
  Front Node: pto.mov_dps
    DefVec (Size 1):
 - Root: arith.constant | Scope: 3
    UseVec (Size 1):
 - Root: arith.constant | Scope: 2
  -> Already Synced at Pipe Level. Skipping.

[MemAnalyze] Analyzing Dependency:
  Now Node: pto.load_dps
    DefVec (Size 1):
 - Root: arith.constant | Scope: 2
    UseVec (Size 1):
 - Root: BlockArg | Scope: 1
  Front Node: pto.load_dps
    DefVec (Size 1):
 - Root: arith.constant | Scope: 2
    UseVec (Size 1):
 - Root: BlockArg | Scope: 1

[DepBetween] Checking dependency...
  Vec A Size: 1
  Vec B Size: 1
  [MemAlias Check]
    Root A: BlockArgument | Type: memref<?xf16, #pto.address_space<gm>>
    Root B: OpResult defined by [arith.constant] | Type: i64
    Scope A: 1, Scope B: 2
    -> Scope Mismatch. False.

[DepBetween] Checking dependency...
  Vec A Size: 1
  Vec B Size: 1
  [MemAlias Check]
    Root A: OpResult defined by [arith.constant] | Type: i64
    Root B: BlockArgument | Type: memref<?xf16, #pto.address_space<gm>>
    Scope A: 2, Scope B: 1
    -> Scope Mismatch. False.

[DepBetween] Checking dependency...
  Vec A Size: 1
  Vec B Size: 1
  [MemAlias Check]
    Root A: OpResult defined by [arith.constant] | Type: i64
    Root B: OpResult defined by [arith.constant] | Type: i64
    Scope A: 2, Scope B: 2
  -> Dependency FOUND!
  -> Intra-Pipe dep on Local Mem (No GM). Skipping Barrier.

[MemAnalyze] Analyzing Dependency:
  Now Node: pto.load_dps
    DefVec (Size 1):
 - Root: arith.constant | Scope: 2
    UseVec (Size 1):
 - Root: BlockArg | Scope: 1
  Front Node: pto.load_dps
    DefVec (Size 1):
 - Root: arith.constant | Scope: 2
    UseVec (Size 1):
 - Root: BlockArg | Scope: 1

[DepBetween] Checking dependency...
  Vec A Size: 1
  Vec B Size: 1
  [MemAlias Check]
    Root A: BlockArgument | Type: memref<?xf16, #pto.address_space<gm>>
    Root B: OpResult defined by [arith.constant] | Type: i64
    Scope A: 1, Scope B: 2
    -> Scope Mismatch. False.

[DepBetween] Checking dependency...
  Vec A Size: 1
  Vec B Size: 1
  [MemAlias Check]
    Root A: OpResult defined by [arith.constant] | Type: i64
    Root B: BlockArgument | Type: memref<?xf16, #pto.address_space<gm>>
    Scope A: 2, Scope B: 1
    -> Scope Mismatch. False.

[DepBetween] Checking dependency...
  Vec A Size: 1
  Vec B Size: 1
  [MemAlias Check]
    Root A: OpResult defined by [arith.constant] | Type: i64
    Root B: OpResult defined by [arith.constant] | Type: i64
    Scope A: 2, Scope B: 2
  [Trace] GetRealRoot Start:
    Current: OpResult defined by [arith.constant] | Type: i64
    -> Hit Alloc/Other [arith.constant]. Stop.
  [Trace] GetRealRoot Start:
    Current: OpResult defined by [arith.constant] | Type: i64
    -> Hit Alloc/Other [arith.constant]. Stop.
    [Deep Check] Surface Roots differ. Digging deeper...
      Real Root A: OpResult defined by [arith.constant] | Type: i64
      Real Root B: OpResult defined by [arith.constant] | Type: i64
      -> Mismatch. Real roots differ.
  -> No Dependency.

[MemAnalyze] Analyzing Dependency:
  Now Node: pto.mov_dps
    DefVec (Size 1):
 - Root: arith.constant | Scope: 3
    UseVec (Size 1):
 - Root: arith.constant | Scope: 2
  Front Node: pto.mov_dps
    DefVec (Size 1):
 - Root: arith.constant | Scope: 4
    UseVec (Size 1):
 - Root: arith.constant | Scope: 2
  -> Already Synced at Pipe Level. Skipping.

[MemAnalyze] Analyzing Dependency:
  Now Node: pto.mov_dps
    DefVec (Size 1):
 - Root: arith.constant | Scope: 3
    UseVec (Size 1):
 - Root: arith.constant | Scope: 2
  Front Node: pto.mov_dps
    DefVec (Size 1):
 - Root: arith.constant | Scope: 3
    UseVec (Size 1):
 - Root: arith.constant | Scope: 2
  -> Already Synced at Pipe Level. Skipping.

[MemAnalyze] Analyzing Dependency:
  Now Node: pto.mov_dps
    DefVec (Size 1):
 - Root: arith.constant | Scope: 3
    UseVec (Size 1):
 - Root: arith.constant | Scope: 2
  Front Node: pto.load_dps
    DefVec (Size 1):
 - Root: arith.constant | Scope: 2
    UseVec (Size 1):
 - Root: BlockArg | Scope: 1
  -> Already Synced at Pipe Level. Skipping.

[MemAnalyze] Analyzing Dependency:
  Now Node: pto.mov_dps
    DefVec (Size 1):
 - Root: arith.constant | Scope: 3
    UseVec (Size 1):
 - Root: arith.constant | Scope: 2
  Front Node: pto.load_dps
    DefVec (Size 1):
 - Root: arith.constant | Scope: 2
    UseVec (Size 1):
 - Root: BlockArg | Scope: 1
  -> Already Synced at Pipe Level. Skipping.

[MemAnalyze] Analyzing Dependency:
  Now Node: pto.mov_dps
    DefVec (Size 1):
 - Root: arith.constant | Scope: 4
    UseVec (Size 1):
 - Root: arith.constant | Scope: 2
  Front Node: pto.mov_dps
    DefVec (Size 1):
 - Root: arith.constant | Scope: 4
    UseVec (Size 1):
 - Root: arith.constant | Scope: 2
  -> Already Synced at Pipe Level. Skipping.

[MemAnalyze] Analyzing Dependency:
  Now Node: pto.mov_dps
    DefVec (Size 1):
 - Root: arith.constant | Scope: 4
    UseVec (Size 1):
 - Root: arith.constant | Scope: 2
  Front Node: pto.mov_dps
    DefVec (Size 1):
 - Root: arith.constant | Scope: 3
    UseVec (Size 1):
 - Root: arith.constant | Scope: 2
  -> Already Synced at Pipe Level. Skipping.

[MemAnalyze] Analyzing Dependency:
  Now Node: pto.mov_dps
    DefVec (Size 1):
 - Root: arith.constant | Scope: 4
    UseVec (Size 1):
 - Root: arith.constant | Scope: 2
  Front Node: pto.load_dps
    DefVec (Size 1):
 - Root: arith.constant | Scope: 2
    UseVec (Size 1):
 - Root: BlockArg | Scope: 1
  -> Already Synced at Pipe Level. Skipping.

[MemAnalyze] Analyzing Dependency:
  Now Node: pto.mov_dps
    DefVec (Size 1):
 - Root: arith.constant | Scope: 4
    UseVec (Size 1):
 - Root: arith.constant | Scope: 2
  Front Node: pto.load_dps
    DefVec (Size 1):
 - Root: arith.constant | Scope: 2
    UseVec (Size 1):
 - Root: BlockArg | Scope: 1
  -> Already Synced at Pipe Level. Skipping.

[MemAnalyze] Analyzing Dependency:
  Now Node: pto.store_dps
    DefVec (Size 1):
 - Root: BlockArg | Scope: 1
    UseVec (Size 1):
 - Root: arith.constant | Scope: 5
  Front Node: pto.mov_dps
    DefVec (Size 1):
 - Root: arith.constant | Scope: 4
    UseVec (Size 1):
 - Root: arith.constant | Scope: 2

[DepBetween] Checking dependency...
  Vec A Size: 1
  Vec B Size: 1
  [MemAlias Check]
    Root A: OpResult defined by [arith.constant] | Type: i64
    Root B: OpResult defined by [arith.constant] | Type: i64
    Scope A: 5, Scope B: 4
    -> Scope Mismatch. False.

[DepBetween] Checking dependency...
  Vec A Size: 1
  Vec B Size: 1
  [MemAlias Check]
    Root A: BlockArgument | Type: memref<?xf32, #pto.address_space<gm>>
    Root B: OpResult defined by [arith.constant] | Type: i64
    Scope A: 1, Scope B: 2
    -> Scope Mismatch. False.

[DepBetween] Checking dependency...
  Vec A Size: 1
  Vec B Size: 1
  [MemAlias Check]
    Root A: BlockArgument | Type: memref<?xf32, #pto.address_space<gm>>
    Root B: OpResult defined by [arith.constant] | Type: i64
    Scope A: 1, Scope B: 4
    -> Scope Mismatch. False.
  -> No Dependency.

[MemAnalyze] Analyzing Dependency:
  Now Node: pto.store_dps
    DefVec (Size 1):
 - Root: BlockArg | Scope: 1
    UseVec (Size 1):
 - Root: arith.constant | Scope: 5
  Front Node: pto.mov_dps
    DefVec (Size 1):
 - Root: arith.constant | Scope: 3
    UseVec (Size 1):
 - Root: arith.constant | Scope: 2

[DepBetween] Checking dependency...
  Vec A Size: 1
  Vec B Size: 1
  [MemAlias Check]
    Root A: OpResult defined by [arith.constant] | Type: i64
    Root B: OpResult defined by [arith.constant] | Type: i64
    Scope A: 5, Scope B: 3
    -> Scope Mismatch. False.

[DepBetween] Checking dependency...
  Vec A Size: 1
  Vec B Size: 1
  [MemAlias Check]
    Root A: BlockArgument | Type: memref<?xf32, #pto.address_space<gm>>
    Root B: OpResult defined by [arith.constant] | Type: i64
    Scope A: 1, Scope B: 2
    -> Scope Mismatch. False.

[DepBetween] Checking dependency...
  Vec A Size: 1
  Vec B Size: 1
  [MemAlias Check]
    Root A: BlockArgument | Type: memref<?xf32, #pto.address_space<gm>>
    Root B: OpResult defined by [arith.constant] | Type: i64
    Scope A: 1, Scope B: 3
    -> Scope Mismatch. False.
  -> No Dependency.

[MemAnalyze] Analyzing Dependency:
  Now Node: pto.store_dps
    DefVec (Size 1):
 - Root: BlockArg | Scope: 1
    UseVec (Size 1):
 - Root: arith.constant | Scope: 5
  Front Node: pto.load_dps
    DefVec (Size 1):
 - Root: arith.constant | Scope: 2
    UseVec (Size 1):
 - Root: BlockArg | Scope: 1

[DepBetween] Checking dependency...
  Vec A Size: 1
  Vec B Size: 1
  [MemAlias Check]
    Root A: OpResult defined by [arith.constant] | Type: i64
    Root B: OpResult defined by [arith.constant] | Type: i64
    Scope A: 5, Scope B: 2
    -> Scope Mismatch. False.

[DepBetween] Checking dependency...
  Vec A Size: 1
  Vec B Size: 1
  [MemAlias Check]
    Root A: BlockArgument | Type: memref<?xf32, #pto.address_space<gm>>
    Root B: BlockArgument | Type: memref<?xf16, #pto.address_space<gm>>
    Scope A: 1, Scope B: 1
  [Trace] GetRealRoot Start:
    Current: BlockArgument | Type: memref<?xf32, #pto.address_space<gm>>
    -> Reached BlockArgument. Stop.
  [Trace] GetRealRoot Start:
    Current: BlockArgument | Type: memref<?xf16, #pto.address_space<gm>>
    -> Reached BlockArgument. Stop.

[DepBetween] Checking dependency...
  Vec A Size: 1
  Vec B Size: 1
  [MemAlias Check]
    Root A: BlockArgument | Type: memref<?xf32, #pto.address_space<gm>>
    Root B: OpResult defined by [arith.constant] | Type: i64
    Scope A: 1, Scope B: 2
    -> Scope Mismatch. False.
  -> No Dependency.

[MemAnalyze] Analyzing Dependency:
  Now Node: pto.store_dps
    DefVec (Size 1):
 - Root: BlockArg | Scope: 1
    UseVec (Size 1):
 - Root: arith.constant | Scope: 5
  Front Node: pto.load_dps
    DefVec (Size 1):
 - Root: arith.constant | Scope: 2
    UseVec (Size 1):
 - Root: BlockArg | Scope: 1

[DepBetween] Checking dependency...
  Vec A Size: 1
  Vec B Size: 1
  [MemAlias Check]
    Root A: OpResult defined by [arith.constant] | Type: i64
    Root B: OpResult defined by [arith.constant] | Type: i64
    Scope A: 5, Scope B: 2
    -> Scope Mismatch. False.

[DepBetween] Checking dependency...
  Vec A Size: 1
  Vec B Size: 1
  [MemAlias Check]
    Root A: BlockArgument | Type: memref<?xf32, #pto.address_space<gm>>
    Root B: BlockArgument | Type: memref<?xf16, #pto.address_space<gm>>
    Scope A: 1, Scope B: 1
  [Trace] GetRealRoot Start:
    Current: BlockArgument | Type: memref<?xf32, #pto.address_space<gm>>
    -> Reached BlockArgument. Stop.
  [Trace] GetRealRoot Start:
    Current: BlockArgument | Type: memref<?xf16, #pto.address_space<gm>>
    -> Reached BlockArgument. Stop.

[DepBetween] Checking dependency...
  Vec A Size: 1
  Vec B Size: 1
  [MemAlias Check]
    Root A: BlockArgument | Type: memref<?xf32, #pto.address_space<gm>>
    Root B: OpResult defined by [arith.constant] | Type: i64
    Scope A: 1, Scope B: 2
    -> Scope Mismatch. False.
  -> No Dependency.

[MemAnalyze] Analyzing Dependency:
  Now Node: pto.store_dps
    DefVec (Size 1):
 - Root: BlockArg | Scope: 1
    UseVec (Size 1):
 - Root: arith.constant | Scope: 5
  Front Node: pto.matmul_dps
    DefVec (Size 1):
 - Root: arith.constant | Scope: 5
    UseVec (Size 2):
 - Root: arith.constant | Scope: 3
 - Root: arith.constant | Scope: 4

[DepBetween] Checking dependency...
  Vec A Size: 1
  Vec B Size: 1
  [MemAlias Check]
    Root A: OpResult defined by [arith.constant] | Type: i64
    Root B: OpResult defined by [arith.constant] | Type: i64
    Scope A: 5, Scope B: 5

[DepBetween] Checking dependency...
  Vec A Size: 1
  Vec B Size: 2
  [MemAlias Check]
    Root A: BlockArgument | Type: memref<?xf32, #pto.address_space<gm>>
    Root B: OpResult defined by [arith.constant] | Type: i64
    Scope A: 1, Scope B: 3
    -> Scope Mismatch. False.
  [MemAlias Check]
    Root A: BlockArgument | Type: memref<?xf32, #pto.address_space<gm>>
    Root B: OpResult defined by [arith.constant] | Type: i64
    Scope A: 1, Scope B: 4
    -> Scope Mismatch. False.

[DepBetween] Checking dependency...
  Vec A Size: 1
  Vec B Size: 1
  [MemAlias Check]
    Root A: BlockArgument | Type: memref<?xf32, #pto.address_space<gm>>
    Root B: OpResult defined by [arith.constant] | Type: i64
    Scope A: 1, Scope B: 5
    -> Scope Mismatch. False.
  -> Dependency FOUND!
 [Trace Insert] SET_EVENT at Node 8 (POST)
 [Trace Insert] WAIT_EVENT at Node 15 (PRE)
 [Trace Record] Updating Record for Node 8, SetPipe=2

[MemAnalyze] Analyzing Dependency:
  Now Node: pto.store_dps
    DefVec (Size 1):
 - Root: BlockArg | Scope: 1
    UseVec (Size 1):
 - Root: arith.constant | Scope: 5
  Front Node: pto.mov_dps
    DefVec (Size 1):
 - Root: arith.constant | Scope: 4
    UseVec (Size 1):
 - Root: arith.constant | Scope: 2

[DepBetween] Checking dependency...
  Vec A Size: 1
  Vec B Size: 1
  [MemAlias Check]
    Root A: OpResult defined by [arith.constant] | Type: i64
    Root B: OpResult defined by [arith.constant] | Type: i64
    Scope A: 5, Scope B: 4
    -> Scope Mismatch. False.

[DepBetween] Checking dependency...
  Vec A Size: 1
  Vec B Size: 1
  [MemAlias Check]
    Root A: BlockArgument | Type: memref<?xf32, #pto.address_space<gm>>
    Root B: OpResult defined by [arith.constant] | Type: i64
    Scope A: 1, Scope B: 2
    -> Scope Mismatch. False.

[DepBetween] Checking dependency...
  Vec A Size: 1
  Vec B Size: 1
  [MemAlias Check]
    Root A: BlockArgument | Type: memref<?xf32, #pto.address_space<gm>>
    Root B: OpResult defined by [arith.constant] | Type: i64
    Scope A: 1, Scope B: 4
    -> Scope Mismatch. False.
  -> No Dependency.

[MemAnalyze] Analyzing Dependency:
  Now Node: pto.store_dps
    DefVec (Size 1):
 - Root: BlockArg | Scope: 1
    UseVec (Size 1):
 - Root: arith.constant | Scope: 5
  Front Node: pto.mov_dps
    DefVec (Size 1):
 - Root: arith.constant | Scope: 3
    UseVec (Size 1):
 - Root: arith.constant | Scope: 2

[DepBetween] Checking dependency...
  Vec A Size: 1
  Vec B Size: 1
  [MemAlias Check]
    Root A: OpResult defined by [arith.constant] | Type: i64
    Root B: OpResult defined by [arith.constant] | Type: i64
    Scope A: 5, Scope B: 3
    -> Scope Mismatch. False.

[DepBetween] Checking dependency...
  Vec A Size: 1
  Vec B Size: 1
  [MemAlias Check]
    Root A: BlockArgument | Type: memref<?xf32, #pto.address_space<gm>>
    Root B: OpResult defined by [arith.constant] | Type: i64
    Scope A: 1, Scope B: 2
    -> Scope Mismatch. False.

[DepBetween] Checking dependency...
  Vec A Size: 1
  Vec B Size: 1
  [MemAlias Check]
    Root A: BlockArgument | Type: memref<?xf32, #pto.address_space<gm>>
    Root B: OpResult defined by [arith.constant] | Type: i64
    Scope A: 1, Scope B: 3
    -> Scope Mismatch. False.
  -> No Dependency.

[MemAnalyze] Analyzing Dependency:
  Now Node: pto.store_dps
    DefVec (Size 1):
 - Root: BlockArg | Scope: 1
    UseVec (Size 1):
 - Root: arith.constant | Scope: 5
  Front Node: pto.load_dps
    DefVec (Size 1):
 - Root: arith.constant | Scope: 2
    UseVec (Size 1):
 - Root: BlockArg | Scope: 1

[DepBetween] Checking dependency...
  Vec A Size: 1
  Vec B Size: 1
  [MemAlias Check]
    Root A: OpResult defined by [arith.constant] | Type: i64
    Root B: OpResult defined by [arith.constant] | Type: i64
    Scope A: 5, Scope B: 2
    -> Scope Mismatch. False.

[DepBetween] Checking dependency...
  Vec A Size: 1
  Vec B Size: 1
  [MemAlias Check]
    Root A: BlockArgument | Type: memref<?xf32, #pto.address_space<gm>>
    Root B: BlockArgument | Type: memref<?xf16, #pto.address_space<gm>>
    Scope A: 1, Scope B: 1
  [Trace] GetRealRoot Start:
    Current: BlockArgument | Type: memref<?xf32, #pto.address_space<gm>>
    -> Reached BlockArgument. Stop.
  [Trace] GetRealRoot Start:
    Current: BlockArgument | Type: memref<?xf16, #pto.address_space<gm>>
    -> Reached BlockArgument. Stop.

[DepBetween] Checking dependency...
  Vec A Size: 1
  Vec B Size: 1
  [MemAlias Check]
    Root A: BlockArgument | Type: memref<?xf32, #pto.address_space<gm>>
    Root B: OpResult defined by [arith.constant] | Type: i64
    Scope A: 1, Scope B: 2
    -> Scope Mismatch. False.
  -> No Dependency.

[MemAnalyze] Analyzing Dependency:
  Now Node: pto.store_dps
    DefVec (Size 1):
 - Root: BlockArg | Scope: 1
    UseVec (Size 1):
 - Root: arith.constant | Scope: 5
  Front Node: pto.load_dps
    DefVec (Size 1):
 - Root: arith.constant | Scope: 2
    UseVec (Size 1):
 - Root: BlockArg | Scope: 1

[DepBetween] Checking dependency...
  Vec A Size: 1
  Vec B Size: 1
  [MemAlias Check]
    Root A: OpResult defined by [arith.constant] | Type: i64
    Root B: OpResult defined by [arith.constant] | Type: i64
    Scope A: 5, Scope B: 2
    -> Scope Mismatch. False.

[DepBetween] Checking dependency...
  Vec A Size: 1
  Vec B Size: 1
  [MemAlias Check]
    Root A: BlockArgument | Type: memref<?xf32, #pto.address_space<gm>>
    Root B: BlockArgument | Type: memref<?xf16, #pto.address_space<gm>>
    Scope A: 1, Scope B: 1
  [Trace] GetRealRoot Start:
    Current: BlockArgument | Type: memref<?xf32, #pto.address_space<gm>>
    -> Reached BlockArgument. Stop.
  [Trace] GetRealRoot Start:
    Current: BlockArgument | Type: memref<?xf16, #pto.address_space<gm>>
    -> Reached BlockArgument. Stop.

[DepBetween] Checking dependency...
  Vec A Size: 1
  Vec B Size: 1
  [MemAlias Check]
    Root A: BlockArgument | Type: memref<?xf32, #pto.address_space<gm>>
    Root B: OpResult defined by [arith.constant] | Type: i64
    Scope A: 1, Scope B: 2
    -> Scope Mismatch. False.
  -> No Dependency.

[MemAnalyze] Analyzing Dependency:
  Now Node: pto.load_dps
    DefVec (Size 1):
 - Root: arith.constant | Scope: 2
    UseVec (Size 1):
 - Root: BlockArg | Scope: 1
  Front Node: pto.store_dps
    DefVec (Size 1):
 - Root: BlockArg | Scope: 1
    UseVec (Size 1):
 - Root: arith.constant | Scope: 5

[DepBetween] Checking dependency...
  Vec A Size: 1
  Vec B Size: 1
  [MemAlias Check]
    Root A: BlockArgument | Type: memref<?xf16, #pto.address_space<gm>>
    Root B: BlockArgument | Type: memref<?xf32, #pto.address_space<gm>>
    Scope A: 1, Scope B: 1
  [Trace] GetRealRoot Start:
    Current: BlockArgument | Type: memref<?xf16, #pto.address_space<gm>>
    -> Reached BlockArgument. Stop.
  [Trace] GetRealRoot Start:
    Current: BlockArgument | Type: memref<?xf32, #pto.address_space<gm>>
    -> Reached BlockArgument. Stop.

[DepBetween] Checking dependency...
  Vec A Size: 1
  Vec B Size: 1
  [MemAlias Check]
    Root A: OpResult defined by [arith.constant] | Type: i64
    Root B: OpResult defined by [arith.constant] | Type: i64
    Scope A: 2, Scope B: 5
    -> Scope Mismatch. False.

[DepBetween] Checking dependency...
  Vec A Size: 1
  Vec B Size: 1
  [MemAlias Check]
    Root A: OpResult defined by [arith.constant] | Type: i64
    Root B: BlockArgument | Type: memref<?xf32, #pto.address_space<gm>>
    Scope A: 2, Scope B: 1
    -> Scope Mismatch. False.
  -> No Dependency.

[MemAnalyze] Analyzing Dependency:
  Now Node: pto.load_dps
    DefVec (Size 1):
 - Root: arith.constant | Scope: 2
    UseVec (Size 1):
 - Root: BlockArg | Scope: 1
  Front Node: pto.mov_dps
    DefVec (Size 1):
 - Root: arith.constant | Scope: 4
    UseVec (Size 1):
 - Root: arith.constant | Scope: 2
  -> Already Synced at Pipe Level. Skipping.

[MemAnalyze] Analyzing Dependency:
  Now Node: pto.load_dps
    DefVec (Size 1):
 - Root: arith.constant | Scope: 2
    UseVec (Size 1):
 - Root: BlockArg | Scope: 1
  Front Node: pto.mov_dps
    DefVec (Size 1):
 - Root: arith.constant | Scope: 3
    UseVec (Size 1):
 - Root: arith.constant | Scope: 2
  -> Already Synced at Pipe Level. Skipping.

[MemAnalyze] Analyzing Dependency:
  Now Node: pto.load_dps
    DefVec (Size 1):
 - Root: arith.constant | Scope: 2
    UseVec (Size 1):
 - Root: BlockArg | Scope: 1
  Front Node: pto.load_dps
    DefVec (Size 1):
 - Root: arith.constant | Scope: 2
    UseVec (Size 1):
 - Root: BlockArg | Scope: 1

[DepBetween] Checking dependency...
  Vec A Size: 1
  Vec B Size: 1
  [MemAlias Check]
    Root A: BlockArgument | Type: memref<?xf16, #pto.address_space<gm>>
    Root B: OpResult defined by [arith.constant] | Type: i64
    Scope A: 1, Scope B: 2
    -> Scope Mismatch. False.

[DepBetween] Checking dependency...
  Vec A Size: 1
  Vec B Size: 1
  [MemAlias Check]
    Root A: OpResult defined by [arith.constant] | Type: i64
    Root B: BlockArgument | Type: memref<?xf16, #pto.address_space<gm>>
    Scope A: 2, Scope B: 1
    -> Scope Mismatch. False.

[DepBetween] Checking dependency...
  Vec A Size: 1
  Vec B Size: 1
  [MemAlias Check]
    Root A: OpResult defined by [arith.constant] | Type: i64
    Root B: OpResult defined by [arith.constant] | Type: i64
    Scope A: 2, Scope B: 2
  [Trace] GetRealRoot Start:
    Current: OpResult defined by [arith.constant] | Type: i64
    -> Hit Alloc/Other [arith.constant]. Stop.
  [Trace] GetRealRoot Start:
    Current: OpResult defined by [arith.constant] | Type: i64
    -> Hit Alloc/Other [arith.constant]. Stop.
    [Deep Check] Surface Roots differ. Digging deeper...
      Real Root A: OpResult defined by [arith.constant] | Type: i64
      Real Root B: OpResult defined by [arith.constant] | Type: i64
      -> Mismatch. Real roots differ.
  -> No Dependency.

[MemAnalyze] Analyzing Dependency:
  Now Node: pto.load_dps
    DefVec (Size 1):
 - Root: arith.constant | Scope: 2
    UseVec (Size 1):
 - Root: BlockArg | Scope: 1
  Front Node: pto.load_dps
    DefVec (Size 1):
 - Root: arith.constant | Scope: 2
    UseVec (Size 1):
 - Root: BlockArg | Scope: 1

[DepBetween] Checking dependency...
  Vec A Size: 1
  Vec B Size: 1
  [MemAlias Check]
    Root A: BlockArgument | Type: memref<?xf16, #pto.address_space<gm>>
    Root B: OpResult defined by [arith.constant] | Type: i64
    Scope A: 1, Scope B: 2
    -> Scope Mismatch. False.

[DepBetween] Checking dependency...
  Vec A Size: 1
  Vec B Size: 1
  [MemAlias Check]
    Root A: OpResult defined by [arith.constant] | Type: i64
    Root B: BlockArgument | Type: memref<?xf16, #pto.address_space<gm>>
    Scope A: 2, Scope B: 1
    -> Scope Mismatch. False.

[DepBetween] Checking dependency...
  Vec A Size: 1
  Vec B Size: 1
  [MemAlias Check]
    Root A: OpResult defined by [arith.constant] | Type: i64
    Root B: OpResult defined by [arith.constant] | Type: i64
    Scope A: 2, Scope B: 2
  -> Dependency FOUND!
  -> Intra-Pipe dep on Local Mem (No GM). Skipping Barrier.

[MemAnalyze] Analyzing Dependency:
  Now Node: pto.load_dps
    DefVec (Size 1):
 - Root: arith.constant | Scope: 2
    UseVec (Size 1):
 - Root: BlockArg | Scope: 1
  Front Node: pto.matmul_dps
    DefVec (Size 1):
 - Root: arith.constant | Scope: 5
    UseVec (Size 2):
 - Root: arith.constant | Scope: 3
 - Root: arith.constant | Scope: 4

[DepBetween] Checking dependency...
  Vec A Size: 1
  Vec B Size: 1
  [MemAlias Check]
    Root A: BlockArgument | Type: memref<?xf16, #pto.address_space<gm>>
    Root B: OpResult defined by [arith.constant] | Type: i64
    Scope A: 1, Scope B: 5
    -> Scope Mismatch. False.

[DepBetween] Checking dependency...
  Vec A Size: 1
  Vec B Size: 2
  [MemAlias Check]
    Root A: OpResult defined by [arith.constant] | Type: i64
    Root B: OpResult defined by [arith.constant] | Type: i64
    Scope A: 2, Scope B: 3
    -> Scope Mismatch. False.
  [MemAlias Check]
    Root A: OpResult defined by [arith.constant] | Type: i64
    Root B: OpResult defined by [arith.constant] | Type: i64
    Scope A: 2, Scope B: 4
    -> Scope Mismatch. False.

[DepBetween] Checking dependency...
  Vec A Size: 1
  Vec B Size: 1
  [MemAlias Check]
    Root A: OpResult defined by [arith.constant] | Type: i64
    Root B: OpResult defined by [arith.constant] | Type: i64
    Scope A: 2, Scope B: 5
    -> Scope Mismatch. False.
  -> No Dependency.

[MemAnalyze] Analyzing Dependency:
  Now Node: pto.load_dps
    DefVec (Size 1):
 - Root: arith.constant | Scope: 2
    UseVec (Size 1):
 - Root: BlockArg | Scope: 1
  Front Node: pto.mov_dps
    DefVec (Size 1):
 - Root: arith.constant | Scope: 4
    UseVec (Size 1):
 - Root: arith.constant | Scope: 2
  -> Already Synced at Pipe Level. Skipping.

[MemAnalyze] Analyzing Dependency:
  Now Node: pto.load_dps
    DefVec (Size 1):
 - Root: arith.constant | Scope: 2
    UseVec (Size 1):
 - Root: BlockArg | Scope: 1
  Front Node: pto.mov_dps
    DefVec (Size 1):
 - Root: arith.constant | Scope: 3
    UseVec (Size 1):
 - Root: arith.constant | Scope: 2
  -> Already Synced at Pipe Level. Skipping.

[MemAnalyze] Analyzing Dependency:
  Now Node: pto.load_dps
    DefVec (Size 1):
 - Root: arith.constant | Scope: 2
    UseVec (Size 1):
 - Root: BlockArg | Scope: 1
  Front Node: pto.load_dps
    DefVec (Size 1):
 - Root: arith.constant | Scope: 2
    UseVec (Size 1):
 - Root: BlockArg | Scope: 1

[DepBetween] Checking dependency...
  Vec A Size: 1
  Vec B Size: 1
  [MemAlias Check]
    Root A: BlockArgument | Type: memref<?xf16, #pto.address_space<gm>>
    Root B: OpResult defined by [arith.constant] | Type: i64
    Scope A: 1, Scope B: 2
    -> Scope Mismatch. False.

[DepBetween] Checking dependency...
  Vec A Size: 1
  Vec B Size: 1
  [MemAlias Check]
    Root A: OpResult defined by [arith.constant] | Type: i64
    Root B: BlockArgument | Type: memref<?xf16, #pto.address_space<gm>>
    Scope A: 2, Scope B: 1
    -> Scope Mismatch. False.

[DepBetween] Checking dependency...
  Vec A Size: 1
  Vec B Size: 1
  [MemAlias Check]
    Root A: OpResult defined by [arith.constant] | Type: i64
    Root B: OpResult defined by [arith.constant] | Type: i64
    Scope A: 2, Scope B: 2
  [Trace] GetRealRoot Start:
    Current: OpResult defined by [arith.constant] | Type: i64
    -> Hit Alloc/Other [arith.constant]. Stop.
  [Trace] GetRealRoot Start:
    Current: OpResult defined by [arith.constant] | Type: i64
    -> Hit Alloc/Other [arith.constant]. Stop.
    [Deep Check] Surface Roots differ. Digging deeper...
      Real Root A: OpResult defined by [arith.constant] | Type: i64
      Real Root B: OpResult defined by [arith.constant] | Type: i64
      -> Mismatch. Real roots differ.
  -> No Dependency.

[MemAnalyze] Analyzing Dependency:
  Now Node: pto.load_dps
    DefVec (Size 1):
 - Root: arith.constant | Scope: 2
    UseVec (Size 1):
 - Root: BlockArg | Scope: 1
  Front Node: pto.load_dps
    DefVec (Size 1):
 - Root: arith.constant | Scope: 2
    UseVec (Size 1):
 - Root: BlockArg | Scope: 1

[DepBetween] Checking dependency...
  Vec A Size: 1
  Vec B Size: 1
  [MemAlias Check]
    Root A: BlockArgument | Type: memref<?xf16, #pto.address_space<gm>>
    Root B: OpResult defined by [arith.constant] | Type: i64
    Scope A: 1, Scope B: 2
    -> Scope Mismatch. False.

[DepBetween] Checking dependency...
  Vec A Size: 1
  Vec B Size: 1
  [MemAlias Check]
    Root A: OpResult defined by [arith.constant] | Type: i64
    Root B: BlockArgument | Type: memref<?xf16, #pto.address_space<gm>>
    Scope A: 2, Scope B: 1
    -> Scope Mismatch. False.

[DepBetween] Checking dependency...
  Vec A Size: 1
  Vec B Size: 1
  [MemAlias Check]
    Root A: OpResult defined by [arith.constant] | Type: i64
    Root B: OpResult defined by [arith.constant] | Type: i64
    Scope A: 2, Scope B: 2
  -> Dependency FOUND!
  -> Intra-Pipe dep on Local Mem (No GM). Skipping Barrier.

[MemAnalyze] Analyzing Dependency:
  Now Node: pto.load_dps
    DefVec (Size 1):
 - Root: arith.constant | Scope: 2
    UseVec (Size 1):
 - Root: BlockArg | Scope: 1
  Front Node: pto.store_dps
    DefVec (Size 1):
 - Root: BlockArg | Scope: 1
    UseVec (Size 1):
 - Root: arith.constant | Scope: 5

[DepBetween] Checking dependency...
  Vec A Size: 1
  Vec B Size: 1
  [MemAlias Check]
    Root A: BlockArgument | Type: memref<?xf16, #pto.address_space<gm>>
    Root B: BlockArgument | Type: memref<?xf32, #pto.address_space<gm>>
    Scope A: 1, Scope B: 1
  [Trace] GetRealRoot Start:
    Current: BlockArgument | Type: memref<?xf16, #pto.address_space<gm>>
    -> Reached BlockArgument. Stop.
  [Trace] GetRealRoot Start:
    Current: BlockArgument | Type: memref<?xf32, #pto.address_space<gm>>
    -> Reached BlockArgument. Stop.

[DepBetween] Checking dependency...
  Vec A Size: 1
  Vec B Size: 1
  [MemAlias Check]
    Root A: OpResult defined by [arith.constant] | Type: i64
    Root B: OpResult defined by [arith.constant] | Type: i64
    Scope A: 2, Scope B: 5
    -> Scope Mismatch. False.

[DepBetween] Checking dependency...
  Vec A Size: 1
  Vec B Size: 1
  [MemAlias Check]
    Root A: OpResult defined by [arith.constant] | Type: i64
    Root B: BlockArgument | Type: memref<?xf32, #pto.address_space<gm>>
    Scope A: 2, Scope B: 1
    -> Scope Mismatch. False.
  -> No Dependency.

[MemAnalyze] Analyzing Dependency:
  Now Node: pto.load_dps
    DefVec (Size 1):
 - Root: arith.constant | Scope: 2
    UseVec (Size 1):
 - Root: BlockArg | Scope: 1
  Front Node: pto.mov_dps
    DefVec (Size 1):
 - Root: arith.constant | Scope: 4
    UseVec (Size 1):
 - Root: arith.constant | Scope: 2
  -> Already Synced at Pipe Level. Skipping.

[MemAnalyze] Analyzing Dependency:
  Now Node: pto.load_dps
    DefVec (Size 1):
 - Root: arith.constant | Scope: 2
    UseVec (Size 1):
 - Root: BlockArg | Scope: 1
  Front Node: pto.mov_dps
    DefVec (Size 1):
 - Root: arith.constant | Scope: 3
    UseVec (Size 1):
 - Root: arith.constant | Scope: 2
  -> Already Synced at Pipe Level. Skipping.

[MemAnalyze] Analyzing Dependency:
  Now Node: pto.load_dps
    DefVec (Size 1):
 - Root: arith.constant | Scope: 2
    UseVec (Size 1):
 - Root: BlockArg | Scope: 1
  Front Node: pto.load_dps
    DefVec (Size 1):
 - Root: arith.constant | Scope: 2
    UseVec (Size 1):
 - Root: BlockArg | Scope: 1

[DepBetween] Checking dependency...
  Vec A Size: 1
  Vec B Size: 1
  [MemAlias Check]
    Root A: BlockArgument | Type: memref<?xf16, #pto.address_space<gm>>
    Root B: OpResult defined by [arith.constant] | Type: i64
    Scope A: 1, Scope B: 2
    -> Scope Mismatch. False.

[DepBetween] Checking dependency...
  Vec A Size: 1
  Vec B Size: 1
  [MemAlias Check]
    Root A: OpResult defined by [arith.constant] | Type: i64
    Root B: BlockArgument | Type: memref<?xf16, #pto.address_space<gm>>
    Scope A: 2, Scope B: 1
    -> Scope Mismatch. False.

[DepBetween] Checking dependency...
  Vec A Size: 1
  Vec B Size: 1
  [MemAlias Check]
    Root A: OpResult defined by [arith.constant] | Type: i64
    Root B: OpResult defined by [arith.constant] | Type: i64
    Scope A: 2, Scope B: 2
  -> Dependency FOUND!
  -> Intra-Pipe dep on Local Mem (No GM). Skipping Barrier.

[MemAnalyze] Analyzing Dependency:
  Now Node: pto.load_dps
    DefVec (Size 1):
 - Root: arith.constant | Scope: 2
    UseVec (Size 1):
 - Root: BlockArg | Scope: 1
  Front Node: pto.load_dps
    DefVec (Size 1):
 - Root: arith.constant | Scope: 2
    UseVec (Size 1):
 - Root: BlockArg | Scope: 1

[DepBetween] Checking dependency...
  Vec A Size: 1
  Vec B Size: 1
  [MemAlias Check]
    Root A: BlockArgument | Type: memref<?xf16, #pto.address_space<gm>>
    Root B: OpResult defined by [arith.constant] | Type: i64
    Scope A: 1, Scope B: 2
    -> Scope Mismatch. False.

[DepBetween] Checking dependency...
  Vec A Size: 1
  Vec B Size: 1
  [MemAlias Check]
    Root A: OpResult defined by [arith.constant] | Type: i64
    Root B: BlockArgument | Type: memref<?xf16, #pto.address_space<gm>>
    Scope A: 2, Scope B: 1
    -> Scope Mismatch. False.

[DepBetween] Checking dependency...
  Vec A Size: 1
  Vec B Size: 1
  [MemAlias Check]
    Root A: OpResult defined by [arith.constant] | Type: i64
    Root B: OpResult defined by [arith.constant] | Type: i64
    Scope A: 2, Scope B: 2
  [Trace] GetRealRoot Start:
    Current: OpResult defined by [arith.constant] | Type: i64
    -> Hit Alloc/Other [arith.constant]. Stop.
  [Trace] GetRealRoot Start:
    Current: OpResult defined by [arith.constant] | Type: i64
    -> Hit Alloc/Other [arith.constant]. Stop.
    [Deep Check] Surface Roots differ. Digging deeper...
      Real Root A: OpResult defined by [arith.constant] | Type: i64
      Real Root B: OpResult defined by [arith.constant] | Type: i64
      -> Mismatch. Real roots differ.
  -> No Dependency.

[MemAnalyze] Analyzing Dependency:
  Now Node: pto.load_dps
    DefVec (Size 1):
 - Root: arith.constant | Scope: 2
    UseVec (Size 1):
 - Root: BlockArg | Scope: 1
  Front Node: pto.matmul_dps
    DefVec (Size 1):
 - Root: arith.constant | Scope: 5
    UseVec (Size 2):
 - Root: arith.constant | Scope: 3
 - Root: arith.constant | Scope: 4

[DepBetween] Checking dependency...
  Vec A Size: 1
  Vec B Size: 1
  [MemAlias Check]
    Root A: BlockArgument | Type: memref<?xf16, #pto.address_space<gm>>
    Root B: OpResult defined by [arith.constant] | Type: i64
    Scope A: 1, Scope B: 5
    -> Scope Mismatch. False.

[DepBetween] Checking dependency...
  Vec A Size: 1
  Vec B Size: 2
  [MemAlias Check]
    Root A: OpResult defined by [arith.constant] | Type: i64
    Root B: OpResult defined by [arith.constant] | Type: i64
    Scope A: 2, Scope B: 3
    -> Scope Mismatch. False.
  [MemAlias Check]
    Root A: OpResult defined by [arith.constant] | Type: i64
    Root B: OpResult defined by [arith.constant] | Type: i64
    Scope A: 2, Scope B: 4
    -> Scope Mismatch. False.

[DepBetween] Checking dependency...
  Vec A Size: 1
  Vec B Size: 1
  [MemAlias Check]
    Root A: OpResult defined by [arith.constant] | Type: i64
    Root B: OpResult defined by [arith.constant] | Type: i64
    Scope A: 2, Scope B: 5
    -> Scope Mismatch. False.
  -> No Dependency.

[MemAnalyze] Analyzing Dependency:
  Now Node: pto.load_dps
    DefVec (Size 1):
 - Root: arith.constant | Scope: 2
    UseVec (Size 1):
 - Root: BlockArg | Scope: 1
  Front Node: pto.mov_dps
    DefVec (Size 1):
 - Root: arith.constant | Scope: 4
    UseVec (Size 1):
 - Root: arith.constant | Scope: 2
  -> Already Synced at Pipe Level. Skipping.

[MemAnalyze] Analyzing Dependency:
  Now Node: pto.load_dps
    DefVec (Size 1):
 - Root: arith.constant | Scope: 2
    UseVec (Size 1):
 - Root: BlockArg | Scope: 1
  Front Node: pto.mov_dps
    DefVec (Size 1):
 - Root: arith.constant | Scope: 3
    UseVec (Size 1):
 - Root: arith.constant | Scope: 2
  -> Already Synced at Pipe Level. Skipping.

[MemAnalyze] Analyzing Dependency:
  Now Node: pto.load_dps
    DefVec (Size 1):
 - Root: arith.constant | Scope: 2
    UseVec (Size 1):
 - Root: BlockArg | Scope: 1
  Front Node: pto.load_dps
    DefVec (Size 1):
 - Root: arith.constant | Scope: 2
    UseVec (Size 1):
 - Root: BlockArg | Scope: 1

[DepBetween] Checking dependency...
  Vec A Size: 1
  Vec B Size: 1
  [MemAlias Check]
    Root A: BlockArgument | Type: memref<?xf16, #pto.address_space<gm>>
    Root B: OpResult defined by [arith.constant] | Type: i64
    Scope A: 1, Scope B: 2
    -> Scope Mismatch. False.

[DepBetween] Checking dependency...
  Vec A Size: 1
  Vec B Size: 1
  [MemAlias Check]
    Root A: OpResult defined by [arith.constant] | Type: i64
    Root B: BlockArgument | Type: memref<?xf16, #pto.address_space<gm>>
    Scope A: 2, Scope B: 1
    -> Scope Mismatch. False.

[DepBetween] Checking dependency...
  Vec A Size: 1
  Vec B Size: 1
  [MemAlias Check]
    Root A: OpResult defined by [arith.constant] | Type: i64
    Root B: OpResult defined by [arith.constant] | Type: i64
    Scope A: 2, Scope B: 2
  -> Dependency FOUND!
  -> Intra-Pipe dep on Local Mem (No GM). Skipping Barrier.

[MemAnalyze] Analyzing Dependency:
  Now Node: pto.load_dps
    DefVec (Size 1):
 - Root: arith.constant | Scope: 2
    UseVec (Size 1):
 - Root: BlockArg | Scope: 1
  Front Node: pto.load_dps
    DefVec (Size 1):
 - Root: arith.constant | Scope: 2
    UseVec (Size 1):
 - Root: BlockArg | Scope: 1

[DepBetween] Checking dependency...
  Vec A Size: 1
  Vec B Size: 1
  [MemAlias Check]
    Root A: BlockArgument | Type: memref<?xf16, #pto.address_space<gm>>
    Root B: OpResult defined by [arith.constant] | Type: i64
    Scope A: 1, Scope B: 2
    -> Scope Mismatch. False.

[DepBetween] Checking dependency...
  Vec A Size: 1
  Vec B Size: 1
  [MemAlias Check]
    Root A: OpResult defined by [arith.constant] | Type: i64
    Root B: BlockArgument | Type: memref<?xf16, #pto.address_space<gm>>
    Scope A: 2, Scope B: 1
    -> Scope Mismatch. False.

[DepBetween] Checking dependency...
  Vec A Size: 1
  Vec B Size: 1
  [MemAlias Check]
    Root A: OpResult defined by [arith.constant] | Type: i64
    Root B: OpResult defined by [arith.constant] | Type: i64
    Scope A: 2, Scope B: 2
  [Trace] GetRealRoot Start:
    Current: OpResult defined by [arith.constant] | Type: i64
    -> Hit Alloc/Other [arith.constant]. Stop.
  [Trace] GetRealRoot Start:
    Current: OpResult defined by [arith.constant] | Type: i64
    -> Hit Alloc/Other [arith.constant]. Stop.
    [Deep Check] Surface Roots differ. Digging deeper...
      Real Root A: OpResult defined by [arith.constant] | Type: i64
      Real Root B: OpResult defined by [arith.constant] | Type: i64
      -> Mismatch. Real roots differ.
  -> No Dependency.

[MemAnalyze] Analyzing Dependency:
  Now Node: pto.mov_dps
    DefVec (Size 1):
 - Root: arith.constant | Scope: 3
    UseVec (Size 1):
 - Root: arith.constant | Scope: 2
  Front Node: pto.store_dps
    DefVec (Size 1):
 - Root: BlockArg | Scope: 1
    UseVec (Size 1):
 - Root: arith.constant | Scope: 5

[DepBetween] Checking dependency...
  Vec A Size: 1
  Vec B Size: 1
  [MemAlias Check]
    Root A: OpResult defined by [arith.constant] | Type: i64
    Root B: BlockArgument | Type: memref<?xf32, #pto.address_space<gm>>
    Scope A: 2, Scope B: 1
    -> Scope Mismatch. False.

[DepBetween] Checking dependency...
  Vec A Size: 1
  Vec B Size: 1
  [MemAlias Check]
    Root A: OpResult defined by [arith.constant] | Type: i64
    Root B: OpResult defined by [arith.constant] | Type: i64
    Scope A: 3, Scope B: 5
    -> Scope Mismatch. False.

[DepBetween] Checking dependency...
  Vec A Size: 1
  Vec B Size: 1
  [MemAlias Check]
    Root A: OpResult defined by [arith.constant] | Type: i64
    Root B: BlockArgument | Type: memref<?xf32, #pto.address_space<gm>>
    Scope A: 3, Scope B: 1
    -> Scope Mismatch. False.
  -> No Dependency.

[MemAnalyze] Analyzing Dependency:
  Now Node: pto.mov_dps
    DefVec (Size 1):
 - Root: arith.constant | Scope: 3
    UseVec (Size 1):
 - Root: arith.constant | Scope: 2
  Front Node: pto.mov_dps
    DefVec (Size 1):
 - Root: arith.constant | Scope: 4
    UseVec (Size 1):
 - Root: arith.constant | Scope: 2
  -> Already Synced at Pipe Level. Skipping.

[MemAnalyze] Analyzing Dependency:
  Now Node: pto.mov_dps
    DefVec (Size 1):
 - Root: arith.constant | Scope: 3
    UseVec (Size 1):
 - Root: arith.constant | Scope: 2
  Front Node: pto.mov_dps
    DefVec (Size 1):
 - Root: arith.constant | Scope: 3
    UseVec (Size 1):
 - Root: arith.constant | Scope: 2
  -> Already Synced at Pipe Level. Skipping.

[MemAnalyze] Analyzing Dependency:
  Now Node: pto.mov_dps
    DefVec (Size 1):
 - Root: arith.constant | Scope: 3
    UseVec (Size 1):
 - Root: arith.constant | Scope: 2
  Front Node: pto.load_dps
    DefVec (Size 1):
 - Root: arith.constant | Scope: 2
    UseVec (Size 1):
 - Root: BlockArg | Scope: 1
  -> Already Synced at Pipe Level. Skipping.

[MemAnalyze] Analyzing Dependency:
  Now Node: pto.mov_dps
    DefVec (Size 1):
 - Root: arith.constant | Scope: 3
    UseVec (Size 1):
 - Root: arith.constant | Scope: 2
  Front Node: pto.load_dps
    DefVec (Size 1):
 - Root: arith.constant | Scope: 2
    UseVec (Size 1):
 - Root: BlockArg | Scope: 1
  -> Already Synced at Pipe Level. Skipping.

[MemAnalyze] Analyzing Dependency:
  Now Node: pto.mov_dps
    DefVec (Size 1):
 - Root: arith.constant | Scope: 3
    UseVec (Size 1):
 - Root: arith.constant | Scope: 2
  Front Node: pto.matmul_dps
    DefVec (Size 1):
 - Root: arith.constant | Scope: 5
    UseVec (Size 2):
 - Root: arith.constant | Scope: 3
 - Root: arith.constant | Scope: 4
  -> Already Synced at Pipe Level. Skipping.

[MemAnalyze] Analyzing Dependency:
  Now Node: pto.mov_dps
    DefVec (Size 1):
 - Root: arith.constant | Scope: 3
    UseVec (Size 1):
 - Root: arith.constant | Scope: 2
  Front Node: pto.mov_dps
    DefVec (Size 1):
 - Root: arith.constant | Scope: 4
    UseVec (Size 1):
 - Root: arith.constant | Scope: 2
  -> Already Synced at Pipe Level. Skipping.

[MemAnalyze] Analyzing Dependency:
  Now Node: pto.mov_dps
    DefVec (Size 1):
 - Root: arith.constant | Scope: 3
    UseVec (Size 1):
 - Root: arith.constant | Scope: 2
  Front Node: pto.mov_dps
    DefVec (Size 1):
 - Root: arith.constant | Scope: 3
    UseVec (Size 1):
 - Root: arith.constant | Scope: 2
  -> Already Synced at Pipe Level. Skipping.

[MemAnalyze] Analyzing Dependency:
  Now Node: pto.mov_dps
    DefVec (Size 1):
 - Root: arith.constant | Scope: 3
    UseVec (Size 1):
 - Root: arith.constant | Scope: 2
  Front Node: pto.load_dps
    DefVec (Size 1):
 - Root: arith.constant | Scope: 2
    UseVec (Size 1):
 - Root: BlockArg | Scope: 1
  -> Already Synced at Pipe Level. Skipping.

[MemAnalyze] Analyzing Dependency:
  Now Node: pto.mov_dps
    DefVec (Size 1):
 - Root: arith.constant | Scope: 3
    UseVec (Size 1):
 - Root: arith.constant | Scope: 2
  Front Node: pto.load_dps
    DefVec (Size 1):
 - Root: arith.constant | Scope: 2
    UseVec (Size 1):
 - Root: BlockArg | Scope: 1
  -> Already Synced at Pipe Level. Skipping.

[MemAnalyze] Analyzing Dependency:
  Now Node: pto.mov_dps
    DefVec (Size 1):
 - Root: arith.constant | Scope: 4
    UseVec (Size 1):
 - Root: arith.constant | Scope: 2
  Front Node: pto.store_dps
    DefVec (Size 1):
 - Root: BlockArg | Scope: 1
    UseVec (Size 1):
 - Root: arith.constant | Scope: 5

[DepBetween] Checking dependency...
  Vec A Size: 1
  Vec B Size: 1
  [MemAlias Check]
    Root A: OpResult defined by [arith.constant] | Type: i64
    Root B: BlockArgument | Type: memref<?xf32, #pto.address_space<gm>>
    Scope A: 2, Scope B: 1
    -> Scope Mismatch. False.

[DepBetween] Checking dependency...
  Vec A Size: 1
  Vec B Size: 1
  [MemAlias Check]
    Root A: OpResult defined by [arith.constant] | Type: i64
    Root B: OpResult defined by [arith.constant] | Type: i64
    Scope A: 4, Scope B: 5
    -> Scope Mismatch. False.

[DepBetween] Checking dependency...
  Vec A Size: 1
  Vec B Size: 1
  [MemAlias Check]
    Root A: OpResult defined by [arith.constant] | Type: i64
    Root B: BlockArgument | Type: memref<?xf32, #pto.address_space<gm>>
    Scope A: 4, Scope B: 1
    -> Scope Mismatch. False.
  -> No Dependency.

[MemAnalyze] Analyzing Dependency:
  Now Node: pto.mov_dps
    DefVec (Size 1):
 - Root: arith.constant | Scope: 4
    UseVec (Size 1):
 - Root: arith.constant | Scope: 2
  Front Node: pto.mov_dps
    DefVec (Size 1):
 - Root: arith.constant | Scope: 4
    UseVec (Size 1):
 - Root: arith.constant | Scope: 2
  -> Already Synced at Pipe Level. Skipping.

[MemAnalyze] Analyzing Dependency:
  Now Node: pto.mov_dps
    DefVec (Size 1):
 - Root: arith.constant | Scope: 4
    UseVec (Size 1):
 - Root: arith.constant | Scope: 2
  Front Node: pto.mov_dps
    DefVec (Size 1):
 - Root: arith.constant | Scope: 3
    UseVec (Size 1):
 - Root: arith.constant | Scope: 2
  -> Already Synced at Pipe Level. Skipping.

[MemAnalyze] Analyzing Dependency:
  Now Node: pto.mov_dps
    DefVec (Size 1):
 - Root: arith.constant | Scope: 4
    UseVec (Size 1):
 - Root: arith.constant | Scope: 2
  Front Node: pto.load_dps
    DefVec (Size 1):
 - Root: arith.constant | Scope: 2
    UseVec (Size 1):
 - Root: BlockArg | Scope: 1
  -> Already Synced at Pipe Level. Skipping.

[MemAnalyze] Analyzing Dependency:
  Now Node: pto.mov_dps
    DefVec (Size 1):
 - Root: arith.constant | Scope: 4
    UseVec (Size 1):
 - Root: arith.constant | Scope: 2
  Front Node: pto.load_dps
    DefVec (Size 1):
 - Root: arith.constant | Scope: 2
    UseVec (Size 1):
 - Root: BlockArg | Scope: 1
  -> Already Synced at Pipe Level. Skipping.

[MemAnalyze] Analyzing Dependency:
  Now Node: pto.mov_dps
    DefVec (Size 1):
 - Root: arith.constant | Scope: 4
    UseVec (Size 1):
 - Root: arith.constant | Scope: 2
  Front Node: pto.matmul_dps
    DefVec (Size 1):
 - Root: arith.constant | Scope: 5
    UseVec (Size 2):
 - Root: arith.constant | Scope: 3
 - Root: arith.constant | Scope: 4
  -> Already Synced at Pipe Level. Skipping.

[MemAnalyze] Analyzing Dependency:
  Now Node: pto.mov_dps
    DefVec (Size 1):
 - Root: arith.constant | Scope: 4
    UseVec (Size 1):
 - Root: arith.constant | Scope: 2
  Front Node: pto.mov_dps
    DefVec (Size 1):
 - Root: arith.constant | Scope: 4
    UseVec (Size 1):
 - Root: arith.constant | Scope: 2
  -> Already Synced at Pipe Level. Skipping.

[MemAnalyze] Analyzing Dependency:
  Now Node: pto.mov_dps
    DefVec (Size 1):
 - Root: arith.constant | Scope: 4
    UseVec (Size 1):
 - Root: arith.constant | Scope: 2
  Front Node: pto.mov_dps
    DefVec (Size 1):
 - Root: arith.constant | Scope: 3
    UseVec (Size 1):
 - Root: arith.constant | Scope: 2
  -> Already Synced at Pipe Level. Skipping.

[MemAnalyze] Analyzing Dependency:
  Now Node: pto.mov_dps
    DefVec (Size 1):
 - Root: arith.constant | Scope: 4
    UseVec (Size 1):
 - Root: arith.constant | Scope: 2
  Front Node: pto.load_dps
    DefVec (Size 1):
 - Root: arith.constant | Scope: 2
    UseVec (Size 1):
 - Root: BlockArg | Scope: 1
  -> Already Synced at Pipe Level. Skipping.

[MemAnalyze] Analyzing Dependency:
  Now Node: pto.mov_dps
    DefVec (Size 1):
 - Root: arith.constant | Scope: 4
    UseVec (Size 1):
 - Root: arith.constant | Scope: 2
  Front Node: pto.load_dps
    DefVec (Size 1):
 - Root: arith.constant | Scope: 2
    UseVec (Size 1):
 - Root: BlockArg | Scope: 1
  -> Already Synced at Pipe Level. Skipping.

[MemAnalyze] Analyzing Dependency:
  Now Node: pto.matmul_dps
    DefVec (Size 1):
 - Root: arith.constant | Scope: 5
    UseVec (Size 2):
 - Root: arith.constant | Scope: 3
 - Root: arith.constant | Scope: 4
  Front Node: pto.store_dps
    DefVec (Size 1):
 - Root: BlockArg | Scope: 1
    UseVec (Size 1):
 - Root: arith.constant | Scope: 5

[DepBetween] Checking dependency...
  Vec A Size: 2
  Vec B Size: 1
  [MemAlias Check]
    Root A: OpResult defined by [arith.constant] | Type: i64
    Root B: BlockArgument | Type: memref<?xf32, #pto.address_space<gm>>
    Scope A: 3, Scope B: 1
    -> Scope Mismatch. False.
  [MemAlias Check]
    Root A: OpResult defined by [arith.constant] | Type: i64
    Root B: BlockArgument | Type: memref<?xf32, #pto.address_space<gm>>
    Scope A: 4, Scope B: 1
    -> Scope Mismatch. False.

[DepBetween] Checking dependency...
  Vec A Size: 1
  Vec B Size: 1
  [MemAlias Check]
    Root A: OpResult defined by [arith.constant] | Type: i64
    Root B: OpResult defined by [arith.constant] | Type: i64
    Scope A: 5, Scope B: 5

[DepBetween] Checking dependency...
  Vec A Size: 1
  Vec B Size: 1
  [MemAlias Check]
    Root A: OpResult defined by [arith.constant] | Type: i64
    Root B: BlockArgument | Type: memref<?xf32, #pto.address_space<gm>>
    Scope A: 5, Scope B: 1
    -> Scope Mismatch. False.
  -> Dependency FOUND!
 [Trace Insert] SET_EVENT at Node 15 (POST)
 [Trace Insert] WAIT_EVENT at Node 8 (PRE)
 [Trace Record] Updating Record for Node 15, SetPipe=5

[MemAnalyze] Analyzing Dependency:
  Now Node: pto.matmul_dps
    DefVec (Size 1):
 - Root: arith.constant | Scope: 5
    UseVec (Size 2):
 - Root: arith.constant | Scope: 3
 - Root: arith.constant | Scope: 4
  Front Node: pto.mov_dps
    DefVec (Size 1):
 - Root: arith.constant | Scope: 4
    UseVec (Size 1):
 - Root: arith.constant | Scope: 2
  -> Already Synced at Pipe Level. Skipping.

[MemAnalyze] Analyzing Dependency:
  Now Node: pto.matmul_dps
    DefVec (Size 1):
 - Root: arith.constant | Scope: 5
    UseVec (Size 2):
 - Root: arith.constant | Scope: 3
 - Root: arith.constant | Scope: 4
  Front Node: pto.mov_dps
    DefVec (Size 1):
 - Root: arith.constant | Scope: 3
    UseVec (Size 1):
 - Root: arith.constant | Scope: 2
  -> Already Synced at Pipe Level. Skipping.

[MemAnalyze] Analyzing Dependency:
  Now Node: pto.matmul_dps
    DefVec (Size 1):
 - Root: arith.constant | Scope: 5
    UseVec (Size 2):
 - Root: arith.constant | Scope: 3
 - Root: arith.constant | Scope: 4
  Front Node: pto.load_dps
    DefVec (Size 1):
 - Root: arith.constant | Scope: 2
    UseVec (Size 1):
 - Root: BlockArg | Scope: 1
  -> Already Synced at Pipe Level. Skipping.

[MemAnalyze] Analyzing Dependency:
  Now Node: pto.matmul_dps
    DefVec (Size 1):
 - Root: arith.constant | Scope: 5
    UseVec (Size 2):
 - Root: arith.constant | Scope: 3
 - Root: arith.constant | Scope: 4
  Front Node: pto.load_dps
    DefVec (Size 1):
 - Root: arith.constant | Scope: 2
    UseVec (Size 1):
 - Root: BlockArg | Scope: 1
  -> Already Synced at Pipe Level. Skipping.

[MemAnalyze] Analyzing Dependency:
  Now Node: pto.matmul_dps
    DefVec (Size 1):
 - Root: arith.constant | Scope: 5
    UseVec (Size 2):
 - Root: arith.constant | Scope: 3
 - Root: arith.constant | Scope: 4
  Front Node: pto.matmul_dps
    DefVec (Size 1):
 - Root: arith.constant | Scope: 5
    UseVec (Size 2):
 - Root: arith.constant | Scope: 3
 - Root: arith.constant | Scope: 4
  -> Already Synced at Pipe Level. Skipping.

[MemAnalyze] Analyzing Dependency:
  Now Node: pto.matmul_dps
    DefVec (Size 1):
 - Root: arith.constant | Scope: 5
    UseVec (Size 2):
 - Root: arith.constant | Scope: 3
 - Root: arith.constant | Scope: 4
  Front Node: pto.mov_dps
    DefVec (Size 1):
 - Root: arith.constant | Scope: 4
    UseVec (Size 1):
 - Root: arith.constant | Scope: 2
  -> Already Synced at Pipe Level. Skipping.

[MemAnalyze] Analyzing Dependency:
  Now Node: pto.matmul_dps
    DefVec (Size 1):
 - Root: arith.constant | Scope: 5
    UseVec (Size 2):
 - Root: arith.constant | Scope: 3
 - Root: arith.constant | Scope: 4
  Front Node: pto.mov_dps
    DefVec (Size 1):
 - Root: arith.constant | Scope: 3
    UseVec (Size 1):
 - Root: arith.constant | Scope: 2
  -> Already Synced at Pipe Level. Skipping.

[MemAnalyze] Analyzing Dependency:
  Now Node: pto.matmul_dps
    DefVec (Size 1):
 - Root: arith.constant | Scope: 5
    UseVec (Size 2):
 - Root: arith.constant | Scope: 3
 - Root: arith.constant | Scope: 4
  Front Node: pto.load_dps
    DefVec (Size 1):
 - Root: arith.constant | Scope: 2
    UseVec (Size 1):
 - Root: BlockArg | Scope: 1
  -> Already Synced at Pipe Level. Skipping.

[MemAnalyze] Analyzing Dependency:
  Now Node: pto.matmul_dps
    DefVec (Size 1):
 - Root: arith.constant | Scope: 5
    UseVec (Size 2):
 - Root: arith.constant | Scope: 3
 - Root: arith.constant | Scope: 4
  Front Node: pto.load_dps
    DefVec (Size 1):
 - Root: arith.constant | Scope: 2
    UseVec (Size 1):
 - Root: BlockArg | Scope: 1
  -> Already Synced at Pipe Level. Skipping.

[MemAnalyze] Analyzing Dependency:
  Now Node: pto.load_dps
    DefVec (Size 1):
 - Root: arith.constant | Scope: 2
    UseVec (Size 1):
 - Root: BlockArg | Scope: 1
  Front Node: pto.store_dps
    DefVec (Size 1):
 - Root: BlockArg | Scope: 1
    UseVec (Size 1):
 - Root: arith.constant | Scope: 5
  -> Already Synced at Pipe Level. Skipping.

[MemAnalyze] Analyzing Dependency:
  Now Node: pto.load_dps
    DefVec (Size 1):
 - Root: arith.constant | Scope: 2
    UseVec (Size 1):
 - Root: BlockArg | Scope: 1
  Front Node: pto.mov_dps
    DefVec (Size 1):
 - Root: arith.constant | Scope: 4
    UseVec (Size 1):
 - Root: arith.constant | Scope: 2
  -> Already Synced at Pipe Level. Skipping.

[MemAnalyze] Analyzing Dependency:
  Now Node: pto.load_dps
    DefVec (Size 1):
 - Root: arith.constant | Scope: 2
    UseVec (Size 1):
 - Root: BlockArg | Scope: 1
  Front Node: pto.mov_dps
    DefVec (Size 1):
 - Root: arith.constant | Scope: 3
    UseVec (Size 1):
 - Root: arith.constant | Scope: 2
  -> Already Synced at Pipe Level. Skipping.

[MemAnalyze] Analyzing Dependency:
  Now Node: pto.load_dps
    DefVec (Size 1):
 - Root: arith.constant | Scope: 2
    UseVec (Size 1):
 - Root: BlockArg | Scope: 1
  Front Node: pto.load_dps
    DefVec (Size 1):
 - Root: arith.constant | Scope: 2
    UseVec (Size 1):
 - Root: BlockArg | Scope: 1
  -> Already Synced at Pipe Level. Skipping.

[MemAnalyze] Analyzing Dependency:
  Now Node: pto.load_dps
    DefVec (Size 1):
 - Root: arith.constant | Scope: 2
    UseVec (Size 1):
 - Root: BlockArg | Scope: 1
  Front Node: pto.load_dps
    DefVec (Size 1):
 - Root: arith.constant | Scope: 2
    UseVec (Size 1):
 - Root: BlockArg | Scope: 1
  -> Already Synced at Pipe Level. Skipping.

[MemAnalyze] Analyzing Dependency:
  Now Node: pto.load_dps
    DefVec (Size 1):
 - Root: arith.constant | Scope: 2
    UseVec (Size 1):
 - Root: BlockArg | Scope: 1
  Front Node: pto.matmul_dps
    DefVec (Size 1):
 - Root: arith.constant | Scope: 5
    UseVec (Size 2):
 - Root: arith.constant | Scope: 3
 - Root: arith.constant | Scope: 4
  -> Already Synced at Pipe Level. Skipping.

[MemAnalyze] Analyzing Dependency:
  Now Node: pto.load_dps
    DefVec (Size 1):
 - Root: arith.constant | Scope: 2
    UseVec (Size 1):
 - Root: BlockArg | Scope: 1
  Front Node: pto.mov_dps
    DefVec (Size 1):
 - Root: arith.constant | Scope: 4
    UseVec (Size 1):
 - Root: arith.constant | Scope: 2
  -> Already Synced at Pipe Level. Skipping.

[MemAnalyze] Analyzing Dependency:
  Now Node: pto.load_dps
    DefVec (Size 1):
 - Root: arith.constant | Scope: 2
    UseVec (Size 1):
 - Root: BlockArg | Scope: 1
  Front Node: pto.mov_dps
    DefVec (Size 1):
 - Root: arith.constant | Scope: 3
    UseVec (Size 1):
 - Root: arith.constant | Scope: 2
  -> Already Synced at Pipe Level. Skipping.

[MemAnalyze] Analyzing Dependency:
  Now Node: pto.load_dps
    DefVec (Size 1):
 - Root: arith.constant | Scope: 2
    UseVec (Size 1):
 - Root: BlockArg | Scope: 1
  Front Node: pto.load_dps
    DefVec (Size 1):
 - Root: arith.constant | Scope: 2
    UseVec (Size 1):
 - Root: BlockArg | Scope: 1
  -> Already Synced at Pipe Level. Skipping.

[MemAnalyze] Analyzing Dependency:
  Now Node: pto.load_dps
    DefVec (Size 1):
 - Root: arith.constant | Scope: 2
    UseVec (Size 1):
 - Root: BlockArg | Scope: 1
  Front Node: pto.load_dps
    DefVec (Size 1):
 - Root: arith.constant | Scope: 2
    UseVec (Size 1):
 - Root: BlockArg | Scope: 1
  -> Already Synced at Pipe Level. Skipping.

[MemAnalyze] Analyzing Dependency:
  Now Node: pto.load_dps
    DefVec (Size 1):
 - Root: arith.constant | Scope: 2
    UseVec (Size 1):
 - Root: BlockArg | Scope: 1
  Front Node: pto.store_dps
    DefVec (Size 1):
 - Root: BlockArg | Scope: 1
    UseVec (Size 1):
 - Root: arith.constant | Scope: 5
  -> Already Synced at Pipe Level. Skipping.

[MemAnalyze] Analyzing Dependency:
  Now Node: pto.load_dps
    DefVec (Size 1):
 - Root: arith.constant | Scope: 2
    UseVec (Size 1):
 - Root: BlockArg | Scope: 1
  Front Node: pto.mov_dps
    DefVec (Size 1):
 - Root: arith.constant | Scope: 4
    UseVec (Size 1):
 - Root: arith.constant | Scope: 2
  -> Already Synced at Pipe Level. Skipping.

[MemAnalyze] Analyzing Dependency:
  Now Node: pto.load_dps
    DefVec (Size 1):
 - Root: arith.constant | Scope: 2
    UseVec (Size 1):
 - Root: BlockArg | Scope: 1
  Front Node: pto.mov_dps
    DefVec (Size 1):
 - Root: arith.constant | Scope: 3
    UseVec (Size 1):
 - Root: arith.constant | Scope: 2
  -> Already Synced at Pipe Level. Skipping.

[MemAnalyze] Analyzing Dependency:
  Now Node: pto.load_dps
    DefVec (Size 1):
 - Root: arith.constant | Scope: 2
    UseVec (Size 1):
 - Root: BlockArg | Scope: 1
  Front Node: pto.load_dps
    DefVec (Size 1):
 - Root: arith.constant | Scope: 2
    UseVec (Size 1):
 - Root: BlockArg | Scope: 1
  -> Already Synced at Pipe Level. Skipping.

[MemAnalyze] Analyzing Dependency:
  Now Node: pto.load_dps
    DefVec (Size 1):
 - Root: arith.constant | Scope: 2
    UseVec (Size 1):
 - Root: BlockArg | Scope: 1
  Front Node: pto.load_dps
    DefVec (Size 1):
 - Root: arith.constant | Scope: 2
    UseVec (Size 1):
 - Root: BlockArg | Scope: 1
  -> Already Synced at Pipe Level. Skipping.

[MemAnalyze] Analyzing Dependency:
  Now Node: pto.load_dps
    DefVec (Size 1):
 - Root: arith.constant | Scope: 2
    UseVec (Size 1):
 - Root: BlockArg | Scope: 1
  Front Node: pto.matmul_dps
    DefVec (Size 1):
 - Root: arith.constant | Scope: 5
    UseVec (Size 2):
 - Root: arith.constant | Scope: 3
 - Root: arith.constant | Scope: 4
  -> Already Synced at Pipe Level. Skipping.

[MemAnalyze] Analyzing Dependency:
  Now Node: pto.load_dps
    DefVec (Size 1):
 - Root: arith.constant | Scope: 2
    UseVec (Size 1):
 - Root: BlockArg | Scope: 1
  Front Node: pto.mov_dps
    DefVec (Size 1):
 - Root: arith.constant | Scope: 4
    UseVec (Size 1):
 - Root: arith.constant | Scope: 2
  -> Already Synced at Pipe Level. Skipping.

[MemAnalyze] Analyzing Dependency:
  Now Node: pto.load_dps
    DefVec (Size 1):
 - Root: arith.constant | Scope: 2
    UseVec (Size 1):
 - Root: BlockArg | Scope: 1
  Front Node: pto.mov_dps
    DefVec (Size 1):
 - Root: arith.constant | Scope: 3
    UseVec (Size 1):
 - Root: arith.constant | Scope: 2
  -> Already Synced at Pipe Level. Skipping.

[MemAnalyze] Analyzing Dependency:
  Now Node: pto.load_dps
    DefVec (Size 1):
 - Root: arith.constant | Scope: 2
    UseVec (Size 1):
 - Root: BlockArg | Scope: 1
  Front Node: pto.load_dps
    DefVec (Size 1):
 - Root: arith.constant | Scope: 2
    UseVec (Size 1):
 - Root: BlockArg | Scope: 1
  -> Already Synced at Pipe Level. Skipping.

[MemAnalyze] Analyzing Dependency:
  Now Node: pto.load_dps
    DefVec (Size 1):
 - Root: arith.constant | Scope: 2
    UseVec (Size 1):
 - Root: BlockArg | Scope: 1
  Front Node: pto.load_dps
    DefVec (Size 1):
 - Root: arith.constant | Scope: 2
    UseVec (Size 1):
 - Root: BlockArg | Scope: 1
  -> Already Synced at Pipe Level. Skipping.

[MemAnalyze] Analyzing Dependency:
  Now Node: pto.mov_dps
    DefVec (Size 1):
 - Root: arith.constant | Scope: 3
    UseVec (Size 1):
 - Root: arith.constant | Scope: 2
  Front Node: pto.store_dps
    DefVec (Size 1):
 - Root: BlockArg | Scope: 1
    UseVec (Size 1):
 - Root: arith.constant | Scope: 5
  -> Already Synced at Pipe Level. Skipping.

[MemAnalyze] Analyzing Dependency:
  Now Node: pto.mov_dps
    DefVec (Size 1):
 - Root: arith.constant | Scope: 3
    UseVec (Size 1):
 - Root: arith.constant | Scope: 2
  Front Node: pto.mov_dps
    DefVec (Size 1):
 - Root: arith.constant | Scope: 4
    UseVec (Size 1):
 - Root: arith.constant | Scope: 2
  -> Already Synced at Pipe Level. Skipping.

[MemAnalyze] Analyzing Dependency:
  Now Node: pto.mov_dps
    DefVec (Size 1):
 - Root: arith.constant | Scope: 3
    UseVec (Size 1):
 - Root: arith.constant | Scope: 2
  Front Node: pto.mov_dps
    DefVec (Size 1):
 - Root: arith.constant | Scope: 3
    UseVec (Size 1):
 - Root: arith.constant | Scope: 2
  -> Already Synced at Pipe Level. Skipping.

[MemAnalyze] Analyzing Dependency:
  Now Node: pto.mov_dps
    DefVec (Size 1):
 - Root: arith.constant | Scope: 3
    UseVec (Size 1):
 - Root: arith.constant | Scope: 2
  Front Node: pto.load_dps
    DefVec (Size 1):
 - Root: arith.constant | Scope: 2
    UseVec (Size 1):
 - Root: BlockArg | Scope: 1
  -> Already Synced at Pipe Level. Skipping.

[MemAnalyze] Analyzing Dependency:
  Now Node: pto.mov_dps
    DefVec (Size 1):
 - Root: arith.constant | Scope: 3
    UseVec (Size 1):
 - Root: arith.constant | Scope: 2
  Front Node: pto.load_dps
    DefVec (Size 1):
 - Root: arith.constant | Scope: 2
    UseVec (Size 1):
 - Root: BlockArg | Scope: 1
  -> Already Synced at Pipe Level. Skipping.

[MemAnalyze] Analyzing Dependency:
  Now Node: pto.mov_dps
    DefVec (Size 1):
 - Root: arith.constant | Scope: 3
    UseVec (Size 1):
 - Root: arith.constant | Scope: 2
  Front Node: pto.matmul_dps
    DefVec (Size 1):
 - Root: arith.constant | Scope: 5
    UseVec (Size 2):
 - Root: arith.constant | Scope: 3
 - Root: arith.constant | Scope: 4
  -> Already Synced at Pipe Level. Skipping.

[MemAnalyze] Analyzing Dependency:
  Now Node: pto.mov_dps
    DefVec (Size 1):
 - Root: arith.constant | Scope: 3
    UseVec (Size 1):
 - Root: arith.constant | Scope: 2
  Front Node: pto.mov_dps
    DefVec (Size 1):
 - Root: arith.constant | Scope: 4
    UseVec (Size 1):
 - Root: arith.constant | Scope: 2
  -> Already Synced at Pipe Level. Skipping.

[MemAnalyze] Analyzing Dependency:
  Now Node: pto.mov_dps
    DefVec (Size 1):
 - Root: arith.constant | Scope: 3
    UseVec (Size 1):
 - Root: arith.constant | Scope: 2
  Front Node: pto.mov_dps
    DefVec (Size 1):
 - Root: arith.constant | Scope: 3
    UseVec (Size 1):
 - Root: arith.constant | Scope: 2
  -> Already Synced at Pipe Level. Skipping.

[MemAnalyze] Analyzing Dependency:
  Now Node: pto.mov_dps
    DefVec (Size 1):
 - Root: arith.constant | Scope: 3
    UseVec (Size 1):
 - Root: arith.constant | Scope: 2
  Front Node: pto.load_dps
    DefVec (Size 1):
 - Root: arith.constant | Scope: 2
    UseVec (Size 1):
 - Root: BlockArg | Scope: 1
  -> Already Synced at Pipe Level. Skipping.

[MemAnalyze] Analyzing Dependency:
  Now Node: pto.mov_dps
    DefVec (Size 1):
 - Root: arith.constant | Scope: 3
    UseVec (Size 1):
 - Root: arith.constant | Scope: 2
  Front Node: pto.load_dps
    DefVec (Size 1):
 - Root: arith.constant | Scope: 2
    UseVec (Size 1):
 - Root: BlockArg | Scope: 1
  -> Already Synced at Pipe Level. Skipping.

[MemAnalyze] Analyzing Dependency:
  Now Node: pto.mov_dps
    DefVec (Size 1):
 - Root: arith.constant | Scope: 4
    UseVec (Size 1):
 - Root: arith.constant | Scope: 2
  Front Node: pto.store_dps
    DefVec (Size 1):
 - Root: BlockArg | Scope: 1
    UseVec (Size 1):
 - Root: arith.constant | Scope: 5
  -> Already Synced at Pipe Level. Skipping.

[MemAnalyze] Analyzing Dependency:
  Now Node: pto.mov_dps
    DefVec (Size 1):
 - Root: arith.constant | Scope: 4
    UseVec (Size 1):
 - Root: arith.constant | Scope: 2
  Front Node: pto.mov_dps
    DefVec (Size 1):
 - Root: arith.constant | Scope: 4
    UseVec (Size 1):
 - Root: arith.constant | Scope: 2
  -> Already Synced at Pipe Level. Skipping.

[MemAnalyze] Analyzing Dependency:
  Now Node: pto.mov_dps
    DefVec (Size 1):
 - Root: arith.constant | Scope: 4
    UseVec (Size 1):
 - Root: arith.constant | Scope: 2
  Front Node: pto.mov_dps
    DefVec (Size 1):
 - Root: arith.constant | Scope: 3
    UseVec (Size 1):
 - Root: arith.constant | Scope: 2
  -> Already Synced at Pipe Level. Skipping.

[MemAnalyze] Analyzing Dependency:
  Now Node: pto.mov_dps
    DefVec (Size 1):
 - Root: arith.constant | Scope: 4
    UseVec (Size 1):
 - Root: arith.constant | Scope: 2
  Front Node: pto.load_dps
    DefVec (Size 1):
 - Root: arith.constant | Scope: 2
    UseVec (Size 1):
 - Root: BlockArg | Scope: 1
  -> Already Synced at Pipe Level. Skipping.

[MemAnalyze] Analyzing Dependency:
  Now Node: pto.mov_dps
    DefVec (Size 1):
 - Root: arith.constant | Scope: 4
    UseVec (Size 1):
 - Root: arith.constant | Scope: 2
  Front Node: pto.load_dps
    DefVec (Size 1):
 - Root: arith.constant | Scope: 2
    UseVec (Size 1):
 - Root: BlockArg | Scope: 1
  -> Already Synced at Pipe Level. Skipping.

[MemAnalyze] Analyzing Dependency:
  Now Node: pto.mov_dps
    DefVec (Size 1):
 - Root: arith.constant | Scope: 4
    UseVec (Size 1):
 - Root: arith.constant | Scope: 2
  Front Node: pto.matmul_dps
    DefVec (Size 1):
 - Root: arith.constant | Scope: 5
    UseVec (Size 2):
 - Root: arith.constant | Scope: 3
 - Root: arith.constant | Scope: 4
  -> Already Synced at Pipe Level. Skipping.

[MemAnalyze] Analyzing Dependency:
  Now Node: pto.mov_dps
    DefVec (Size 1):
 - Root: arith.constant | Scope: 4
    UseVec (Size 1):
 - Root: arith.constant | Scope: 2
  Front Node: pto.mov_dps
    DefVec (Size 1):
 - Root: arith.constant | Scope: 4
    UseVec (Size 1):
 - Root: arith.constant | Scope: 2
  -> Already Synced at Pipe Level. Skipping.

[MemAnalyze] Analyzing Dependency:
  Now Node: pto.mov_dps
    DefVec (Size 1):
 - Root: arith.constant | Scope: 4
    UseVec (Size 1):
 - Root: arith.constant | Scope: 2
  Front Node: pto.mov_dps
    DefVec (Size 1):
 - Root: arith.constant | Scope: 3
    UseVec (Size 1):
 - Root: arith.constant | Scope: 2
  -> Already Synced at Pipe Level. Skipping.

[MemAnalyze] Analyzing Dependency:
  Now Node: pto.mov_dps
    DefVec (Size 1):
 - Root: arith.constant | Scope: 4
    UseVec (Size 1):
 - Root: arith.constant | Scope: 2
  Front Node: pto.load_dps
    DefVec (Size 1):
 - Root: arith.constant | Scope: 2
    UseVec (Size 1):
 - Root: BlockArg | Scope: 1
  -> Already Synced at Pipe Level. Skipping.

[MemAnalyze] Analyzing Dependency:
  Now Node: pto.mov_dps
    DefVec (Size 1):
 - Root: arith.constant | Scope: 4
    UseVec (Size 1):
 - Root: arith.constant | Scope: 2
  Front Node: pto.load_dps
    DefVec (Size 1):
 - Root: arith.constant | Scope: 2
    UseVec (Size 1):
 - Root: BlockArg | Scope: 1
  -> Already Synced at Pipe Level. Skipping.

[MemAnalyze] Analyzing Dependency:
  Now Node: pto.store_dps
    DefVec (Size 1):
 - Root: BlockArg | Scope: 1
    UseVec (Size 1):
 - Root: arith.constant | Scope: 5
  Front Node: pto.store_dps
    DefVec (Size 1):
 - Root: BlockArg | Scope: 1
    UseVec (Size 1):
 - Root: arith.constant | Scope: 5
  -> Already Synced at Pipe Level. Skipping.

[MemAnalyze] Analyzing Dependency:
  Now Node: pto.store_dps
    DefVec (Size 1):
 - Root: BlockArg | Scope: 1
    UseVec (Size 1):
 - Root: arith.constant | Scope: 5
  Front Node: pto.mov_dps
    DefVec (Size 1):
 - Root: arith.constant | Scope: 4
    UseVec (Size 1):
 - Root: arith.constant | Scope: 2
  -> Already Synced at Pipe Level. Skipping.

[MemAnalyze] Analyzing Dependency:
  Now Node: pto.store_dps
    DefVec (Size 1):
 - Root: BlockArg | Scope: 1
    UseVec (Size 1):
 - Root: arith.constant | Scope: 5
  Front Node: pto.mov_dps
    DefVec (Size 1):
 - Root: arith.constant | Scope: 3
    UseVec (Size 1):
 - Root: arith.constant | Scope: 2
  -> Already Synced at Pipe Level. Skipping.

[MemAnalyze] Analyzing Dependency:
  Now Node: pto.store_dps
    DefVec (Size 1):
 - Root: BlockArg | Scope: 1
    UseVec (Size 1):
 - Root: arith.constant | Scope: 5
  Front Node: pto.load_dps
    DefVec (Size 1):
 - Root: arith.constant | Scope: 2
    UseVec (Size 1):
 - Root: BlockArg | Scope: 1
  -> Already Synced at Pipe Level. Skipping.

[MemAnalyze] Analyzing Dependency:
  Now Node: pto.store_dps
    DefVec (Size 1):
 - Root: BlockArg | Scope: 1
    UseVec (Size 1):
 - Root: arith.constant | Scope: 5
  Front Node: pto.load_dps
    DefVec (Size 1):
 - Root: arith.constant | Scope: 2
    UseVec (Size 1):
 - Root: BlockArg | Scope: 1
  -> Already Synced at Pipe Level. Skipping.

[MemAnalyze] Analyzing Dependency:
  Now Node: pto.store_dps
    DefVec (Size 1):
 - Root: BlockArg | Scope: 1
    UseVec (Size 1):
 - Root: arith.constant | Scope: 5
  Front Node: pto.matmul_dps
    DefVec (Size 1):
 - Root: arith.constant | Scope: 5
    UseVec (Size 2):
 - Root: arith.constant | Scope: 3
 - Root: arith.constant | Scope: 4
  -> Already Synced at Pipe Level. Skipping.

[MemAnalyze] Analyzing Dependency:
  Now Node: pto.store_dps
    DefVec (Size 1):
 - Root: BlockArg | Scope: 1
    UseVec (Size 1):
 - Root: arith.constant | Scope: 5
  Front Node: pto.mov_dps
    DefVec (Size 1):
 - Root: arith.constant | Scope: 4
    UseVec (Size 1):
 - Root: arith.constant | Scope: 2
  -> Already Synced at Pipe Level. Skipping.

[MemAnalyze] Analyzing Dependency:
  Now Node: pto.store_dps
    DefVec (Size 1):
 - Root: BlockArg | Scope: 1
    UseVec (Size 1):
 - Root: arith.constant | Scope: 5
  Front Node: pto.mov_dps
    DefVec (Size 1):
 - Root: arith.constant | Scope: 3
    UseVec (Size 1):
 - Root: arith.constant | Scope: 2
  -> Already Synced at Pipe Level. Skipping.

[MemAnalyze] Analyzing Dependency:
  Now Node: pto.store_dps
    DefVec (Size 1):
 - Root: BlockArg | Scope: 1
    UseVec (Size 1):
 - Root: arith.constant | Scope: 5
  Front Node: pto.load_dps
    DefVec (Size 1):
 - Root: arith.constant | Scope: 2
    UseVec (Size 1):
 - Root: BlockArg | Scope: 1
  -> Already Synced at Pipe Level. Skipping.

[MemAnalyze] Analyzing Dependency:
  Now Node: pto.store_dps
    DefVec (Size 1):
 - Root: BlockArg | Scope: 1
    UseVec (Size 1):
 - Root: arith.constant | Scope: 5
  Front Node: pto.load_dps
    DefVec (Size 1):
 - Root: arith.constant | Scope: 2
    UseVec (Size 1):
 - Root: BlockArg | Scope: 1
  -> Already Synced at Pipe Level. Skipping.

[MemAnalyze] Analyzing Dependency:
  Now Node: pto.load_dps
    DefVec (Size 1):
 - Root: arith.constant | Scope: 2
    UseVec (Size 1):
 - Root: BlockArg | Scope: 1
  Front Node: pto.store_dps
    DefVec (Size 1):
 - Root: BlockArg | Scope: 1
    UseVec (Size 1):
 - Root: arith.constant | Scope: 5

[DepBetween] Checking dependency...
  Vec A Size: 1
  Vec B Size: 1
  [MemAlias Check]
    Root A: BlockArgument | Type: memref<?xf16, #pto.address_space<gm>>
    Root B: BlockArgument | Type: memref<?xf32, #pto.address_space<gm>>
    Scope A: 1, Scope B: 1
  [Trace] GetRealRoot Start:
    Current: BlockArgument | Type: memref<?xf16, #pto.address_space<gm>>
    -> Reached BlockArgument. Stop.
  [Trace] GetRealRoot Start:
    Current: BlockArgument | Type: memref<?xf32, #pto.address_space<gm>>
    -> Reached BlockArgument. Stop.

[DepBetween] Checking dependency...
  Vec A Size: 1
  Vec B Size: 1
  [MemAlias Check]
    Root A: OpResult defined by [arith.constant] | Type: i64
    Root B: OpResult defined by [arith.constant] | Type: i64
    Scope A: 2, Scope B: 5
    -> Scope Mismatch. False.

[DepBetween] Checking dependency...
  Vec A Size: 1
  Vec B Size: 1
  [MemAlias Check]
    Root A: OpResult defined by [arith.constant] | Type: i64
    Root B: BlockArgument | Type: memref<?xf32, #pto.address_space<gm>>
    Scope A: 2, Scope B: 1
    -> Scope Mismatch. False.
  -> No Dependency.

[MemAnalyze] Analyzing Dependency:
  Now Node: pto.load_dps
    DefVec (Size 1):
 - Root: arith.constant | Scope: 2
    UseVec (Size 1):
 - Root: BlockArg | Scope: 1
  Front Node: pto.mov_dps
    DefVec (Size 1):
 - Root: arith.constant | Scope: 4
    UseVec (Size 1):
 - Root: arith.constant | Scope: 2
  -> Already Synced at Pipe Level. Skipping.

[MemAnalyze] Analyzing Dependency:
  Now Node: pto.load_dps
    DefVec (Size 1):
 - Root: arith.constant | Scope: 2
    UseVec (Size 1):
 - Root: BlockArg | Scope: 1
  Front Node: pto.mov_dps
    DefVec (Size 1):
 - Root: arith.constant | Scope: 3
    UseVec (Size 1):
 - Root: arith.constant | Scope: 2
  -> Already Synced at Pipe Level. Skipping.

[MemAnalyze] Analyzing Dependency:
  Now Node: pto.load_dps
    DefVec (Size 1):
 - Root: arith.constant | Scope: 2
    UseVec (Size 1):
 - Root: BlockArg | Scope: 1
  Front Node: pto.load_dps
    DefVec (Size 1):
 - Root: arith.constant | Scope: 2
    UseVec (Size 1):
 - Root: BlockArg | Scope: 1

[DepBetween] Checking dependency...
  Vec A Size: 1
  Vec B Size: 1
  [MemAlias Check]
    Root A: BlockArgument | Type: memref<?xf16, #pto.address_space<gm>>
    Root B: OpResult defined by [arith.constant] | Type: i64
    Scope A: 1, Scope B: 2
    -> Scope Mismatch. False.

[DepBetween] Checking dependency...
  Vec A Size: 1
  Vec B Size: 1
  [MemAlias Check]
    Root A: OpResult defined by [arith.constant] | Type: i64
    Root B: BlockArgument | Type: memref<?xf16, #pto.address_space<gm>>
    Scope A: 2, Scope B: 1
    -> Scope Mismatch. False.

[DepBetween] Checking dependency...
  Vec A Size: 1
  Vec B Size: 1
  [MemAlias Check]
    Root A: OpResult defined by [arith.constant] | Type: i64
    Root B: OpResult defined by [arith.constant] | Type: i64
    Scope A: 2, Scope B: 2
  [Trace] GetRealRoot Start:
    Current: OpResult defined by [arith.constant] | Type: i64
    -> Hit Alloc/Other [arith.constant]. Stop.
  [Trace] GetRealRoot Start:
    Current: OpResult defined by [arith.constant] | Type: i64
    -> Hit Alloc/Other [arith.constant]. Stop.
    [Deep Check] Surface Roots differ. Digging deeper...
      Real Root A: OpResult defined by [arith.constant] | Type: i64
      Real Root B: OpResult defined by [arith.constant] | Type: i64
      -> Mismatch. Real roots differ.
  -> No Dependency.

[MemAnalyze] Analyzing Dependency:
  Now Node: pto.load_dps
    DefVec (Size 1):
 - Root: arith.constant | Scope: 2
    UseVec (Size 1):
 - Root: BlockArg | Scope: 1
  Front Node: pto.load_dps
    DefVec (Size 1):
 - Root: arith.constant | Scope: 2
    UseVec (Size 1):
 - Root: BlockArg | Scope: 1

[DepBetween] Checking dependency...
  Vec A Size: 1
  Vec B Size: 1
  [MemAlias Check]
    Root A: BlockArgument | Type: memref<?xf16, #pto.address_space<gm>>
    Root B: OpResult defined by [arith.constant] | Type: i64
    Scope A: 1, Scope B: 2
    -> Scope Mismatch. False.

[DepBetween] Checking dependency...
  Vec A Size: 1
  Vec B Size: 1
  [MemAlias Check]
    Root A: OpResult defined by [arith.constant] | Type: i64
    Root B: BlockArgument | Type: memref<?xf16, #pto.address_space<gm>>
    Scope A: 2, Scope B: 1
    -> Scope Mismatch. False.

[DepBetween] Checking dependency...
  Vec A Size: 1
  Vec B Size: 1
  [MemAlias Check]
    Root A: OpResult defined by [arith.constant] | Type: i64
    Root B: OpResult defined by [arith.constant] | Type: i64
    Scope A: 2, Scope B: 2
  -> Dependency FOUND!
  -> Intra-Pipe dep on Local Mem (No GM). Skipping Barrier.

[MemAnalyze] Analyzing Dependency:
  Now Node: pto.load_dps
    DefVec (Size 1):
 - Root: arith.constant | Scope: 2
    UseVec (Size 1):
 - Root: BlockArg | Scope: 1
  Front Node: pto.matmul_dps
    DefVec (Size 1):
 - Root: arith.constant | Scope: 5
    UseVec (Size 2):
 - Root: arith.constant | Scope: 3
 - Root: arith.constant | Scope: 4

[DepBetween] Checking dependency...
  Vec A Size: 1
  Vec B Size: 1
  [MemAlias Check]
    Root A: BlockArgument | Type: memref<?xf16, #pto.address_space<gm>>
    Root B: OpResult defined by [arith.constant] | Type: i64
    Scope A: 1, Scope B: 5
    -> Scope Mismatch. False.

[DepBetween] Checking dependency...
  Vec A Size: 1
  Vec B Size: 2
  [MemAlias Check]
    Root A: OpResult defined by [arith.constant] | Type: i64
    Root B: OpResult defined by [arith.constant] | Type: i64
    Scope A: 2, Scope B: 3
    -> Scope Mismatch. False.
  [MemAlias Check]
    Root A: OpResult defined by [arith.constant] | Type: i64
    Root B: OpResult defined by [arith.constant] | Type: i64
    Scope A: 2, Scope B: 4
    -> Scope Mismatch. False.

[DepBetween] Checking dependency...
  Vec A Size: 1
  Vec B Size: 1
  [MemAlias Check]
    Root A: OpResult defined by [arith.constant] | Type: i64
    Root B: OpResult defined by [arith.constant] | Type: i64
    Scope A: 2, Scope B: 5
    -> Scope Mismatch. False.
  -> No Dependency.

[MemAnalyze] Analyzing Dependency:
  Now Node: pto.load_dps
    DefVec (Size 1):
 - Root: arith.constant | Scope: 2
    UseVec (Size 1):
 - Root: BlockArg | Scope: 1
  Front Node: pto.mov_dps
    DefVec (Size 1):
 - Root: arith.constant | Scope: 4
    UseVec (Size 1):
 - Root: arith.constant | Scope: 2
  -> Already Synced at Pipe Level. Skipping.

[MemAnalyze] Analyzing Dependency:
  Now Node: pto.load_dps
    DefVec (Size 1):
 - Root: arith.constant | Scope: 2
    UseVec (Size 1):
 - Root: BlockArg | Scope: 1
  Front Node: pto.mov_dps
    DefVec (Size 1):
 - Root: arith.constant | Scope: 3
    UseVec (Size 1):
 - Root: arith.constant | Scope: 2
  -> Already Synced at Pipe Level. Skipping.

[MemAnalyze] Analyzing Dependency:
  Now Node: pto.load_dps
    DefVec (Size 1):
 - Root: arith.constant | Scope: 2
    UseVec (Size 1):
 - Root: BlockArg | Scope: 1
  Front Node: pto.load_dps
    DefVec (Size 1):
 - Root: arith.constant | Scope: 2
    UseVec (Size 1):
 - Root: BlockArg | Scope: 1

[DepBetween] Checking dependency...
  Vec A Size: 1
  Vec B Size: 1
  [MemAlias Check]
    Root A: BlockArgument | Type: memref<?xf16, #pto.address_space<gm>>
    Root B: OpResult defined by [arith.constant] | Type: i64
    Scope A: 1, Scope B: 2
    -> Scope Mismatch. False.

[DepBetween] Checking dependency...
  Vec A Size: 1
  Vec B Size: 1
  [MemAlias Check]
    Root A: OpResult defined by [arith.constant] | Type: i64
    Root B: BlockArgument | Type: memref<?xf16, #pto.address_space<gm>>
    Scope A: 2, Scope B: 1
    -> Scope Mismatch. False.

[DepBetween] Checking dependency...
  Vec A Size: 1
  Vec B Size: 1
  [MemAlias Check]
    Root A: OpResult defined by [arith.constant] | Type: i64
    Root B: OpResult defined by [arith.constant] | Type: i64
    Scope A: 2, Scope B: 2
  [Trace] GetRealRoot Start:
    Current: OpResult defined by [arith.constant] | Type: i64
    -> Hit Alloc/Other [arith.constant]. Stop.
  [Trace] GetRealRoot Start:
    Current: OpResult defined by [arith.constant] | Type: i64
    -> Hit Alloc/Other [arith.constant]. Stop.
    [Deep Check] Surface Roots differ. Digging deeper...
      Real Root A: OpResult defined by [arith.constant] | Type: i64
      Real Root B: OpResult defined by [arith.constant] | Type: i64
      -> Mismatch. Real roots differ.
  -> No Dependency.

[MemAnalyze] Analyzing Dependency:
  Now Node: pto.load_dps
    DefVec (Size 1):
 - Root: arith.constant | Scope: 2
    UseVec (Size 1):
 - Root: BlockArg | Scope: 1
  Front Node: pto.load_dps
    DefVec (Size 1):
 - Root: arith.constant | Scope: 2
    UseVec (Size 1):
 - Root: BlockArg | Scope: 1

[DepBetween] Checking dependency...
  Vec A Size: 1
  Vec B Size: 1
  [MemAlias Check]
    Root A: BlockArgument | Type: memref<?xf16, #pto.address_space<gm>>
    Root B: OpResult defined by [arith.constant] | Type: i64
    Scope A: 1, Scope B: 2
    -> Scope Mismatch. False.

[DepBetween] Checking dependency...
  Vec A Size: 1
  Vec B Size: 1
  [MemAlias Check]
    Root A: OpResult defined by [arith.constant] | Type: i64
    Root B: BlockArgument | Type: memref<?xf16, #pto.address_space<gm>>
    Scope A: 2, Scope B: 1
    -> Scope Mismatch. False.

[DepBetween] Checking dependency...
  Vec A Size: 1
  Vec B Size: 1
  [MemAlias Check]
    Root A: OpResult defined by [arith.constant] | Type: i64
    Root B: OpResult defined by [arith.constant] | Type: i64
    Scope A: 2, Scope B: 2
  -> Dependency FOUND!
  -> Intra-Pipe dep on Local Mem (No GM). Skipping Barrier.

[MemAnalyze] Analyzing Dependency:
  Now Node: pto.load_dps
    DefVec (Size 1):
 - Root: arith.constant | Scope: 2
    UseVec (Size 1):
 - Root: BlockArg | Scope: 1
  Front Node: pto.store_dps
    DefVec (Size 1):
 - Root: BlockArg | Scope: 1
    UseVec (Size 1):
 - Root: arith.constant | Scope: 5

[DepBetween] Checking dependency...
  Vec A Size: 1
  Vec B Size: 1
  [MemAlias Check]
    Root A: BlockArgument | Type: memref<?xf16, #pto.address_space<gm>>
    Root B: BlockArgument | Type: memref<?xf32, #pto.address_space<gm>>
    Scope A: 1, Scope B: 1
  [Trace] GetRealRoot Start:
    Current: BlockArgument | Type: memref<?xf16, #pto.address_space<gm>>
    -> Reached BlockArgument. Stop.
  [Trace] GetRealRoot Start:
    Current: BlockArgument | Type: memref<?xf32, #pto.address_space<gm>>
    -> Reached BlockArgument. Stop.

[DepBetween] Checking dependency...
  Vec A Size: 1
  Vec B Size: 1
  [MemAlias Check]
    Root A: OpResult defined by [arith.constant] | Type: i64
    Root B: OpResult defined by [arith.constant] | Type: i64
    Scope A: 2, Scope B: 5
    -> Scope Mismatch. False.

[DepBetween] Checking dependency...
  Vec A Size: 1
  Vec B Size: 1
  [MemAlias Check]
    Root A: OpResult defined by [arith.constant] | Type: i64
    Root B: BlockArgument | Type: memref<?xf32, #pto.address_space<gm>>
    Scope A: 2, Scope B: 1
    -> Scope Mismatch. False.
  -> No Dependency.

[MemAnalyze] Analyzing Dependency:
  Now Node: pto.load_dps
    DefVec (Size 1):
 - Root: arith.constant | Scope: 2
    UseVec (Size 1):
 - Root: BlockArg | Scope: 1
  Front Node: pto.mov_dps
    DefVec (Size 1):
 - Root: arith.constant | Scope: 4
    UseVec (Size 1):
 - Root: arith.constant | Scope: 2
  -> Already Synced at Pipe Level. Skipping.

[MemAnalyze] Analyzing Dependency:
  Now Node: pto.load_dps
    DefVec (Size 1):
 - Root: arith.constant | Scope: 2
    UseVec (Size 1):
 - Root: BlockArg | Scope: 1
  Front Node: pto.mov_dps
    DefVec (Size 1):
 - Root: arith.constant | Scope: 3
    UseVec (Size 1):
 - Root: arith.constant | Scope: 2
  -> Already Synced at Pipe Level. Skipping.

[MemAnalyze] Analyzing Dependency:
  Now Node: pto.load_dps
    DefVec (Size 1):
 - Root: arith.constant | Scope: 2
    UseVec (Size 1):
 - Root: BlockArg | Scope: 1
  Front Node: pto.load_dps
    DefVec (Size 1):
 - Root: arith.constant | Scope: 2
    UseVec (Size 1):
 - Root: BlockArg | Scope: 1

[DepBetween] Checking dependency...
  Vec A Size: 1
  Vec B Size: 1
  [MemAlias Check]
    Root A: BlockArgument | Type: memref<?xf16, #pto.address_space<gm>>
    Root B: OpResult defined by [arith.constant] | Type: i64
    Scope A: 1, Scope B: 2
    -> Scope Mismatch. False.

[DepBetween] Checking dependency...
  Vec A Size: 1
  Vec B Size: 1
  [MemAlias Check]
    Root A: OpResult defined by [arith.constant] | Type: i64
    Root B: BlockArgument | Type: memref<?xf16, #pto.address_space<gm>>
    Scope A: 2, Scope B: 1
    -> Scope Mismatch. False.

[DepBetween] Checking dependency...
  Vec A Size: 1
  Vec B Size: 1
  [MemAlias Check]
    Root A: OpResult defined by [arith.constant] | Type: i64
    Root B: OpResult defined by [arith.constant] | Type: i64
    Scope A: 2, Scope B: 2
  -> Dependency FOUND!
  -> Intra-Pipe dep on Local Mem (No GM). Skipping Barrier.

[MemAnalyze] Analyzing Dependency:
  Now Node: pto.load_dps
    DefVec (Size 1):
 - Root: arith.constant | Scope: 2
    UseVec (Size 1):
 - Root: BlockArg | Scope: 1
  Front Node: pto.load_dps
    DefVec (Size 1):
 - Root: arith.constant | Scope: 2
    UseVec (Size 1):
 - Root: BlockArg | Scope: 1

[DepBetween] Checking dependency...
  Vec A Size: 1
  Vec B Size: 1
  [MemAlias Check]
    Root A: BlockArgument | Type: memref<?xf16, #pto.address_space<gm>>
    Root B: OpResult defined by [arith.constant] | Type: i64
    Scope A: 1, Scope B: 2
    -> Scope Mismatch. False.

[DepBetween] Checking dependency...
  Vec A Size: 1
  Vec B Size: 1
  [MemAlias Check]
    Root A: OpResult defined by [arith.constant] | Type: i64
    Root B: BlockArgument | Type: memref<?xf16, #pto.address_space<gm>>
    Scope A: 2, Scope B: 1
    -> Scope Mismatch. False.

[DepBetween] Checking dependency...
  Vec A Size: 1
  Vec B Size: 1
  [MemAlias Check]
    Root A: OpResult defined by [arith.constant] | Type: i64
    Root B: OpResult defined by [arith.constant] | Type: i64
    Scope A: 2, Scope B: 2
  [Trace] GetRealRoot Start:
    Current: OpResult defined by [arith.constant] | Type: i64
    -> Hit Alloc/Other [arith.constant]. Stop.
  [Trace] GetRealRoot Start:
    Current: OpResult defined by [arith.constant] | Type: i64
    -> Hit Alloc/Other [arith.constant]. Stop.
    [Deep Check] Surface Roots differ. Digging deeper...
      Real Root A: OpResult defined by [arith.constant] | Type: i64
      Real Root B: OpResult defined by [arith.constant] | Type: i64
      -> Mismatch. Real roots differ.
  -> No Dependency.

[MemAnalyze] Analyzing Dependency:
  Now Node: pto.load_dps
    DefVec (Size 1):
 - Root: arith.constant | Scope: 2
    UseVec (Size 1):
 - Root: BlockArg | Scope: 1
  Front Node: pto.matmul_dps
    DefVec (Size 1):
 - Root: arith.constant | Scope: 5
    UseVec (Size 2):
 - Root: arith.constant | Scope: 3
 - Root: arith.constant | Scope: 4

[DepBetween] Checking dependency...
  Vec A Size: 1
  Vec B Size: 1
  [MemAlias Check]
    Root A: BlockArgument | Type: memref<?xf16, #pto.address_space<gm>>
    Root B: OpResult defined by [arith.constant] | Type: i64
    Scope A: 1, Scope B: 5
    -> Scope Mismatch. False.

[DepBetween] Checking dependency...
  Vec A Size: 1
  Vec B Size: 2
  [MemAlias Check]
    Root A: OpResult defined by [arith.constant] | Type: i64
    Root B: OpResult defined by [arith.constant] | Type: i64
    Scope A: 2, Scope B: 3
    -> Scope Mismatch. False.
  [MemAlias Check]
    Root A: OpResult defined by [arith.constant] | Type: i64
    Root B: OpResult defined by [arith.constant] | Type: i64
    Scope A: 2, Scope B: 4
    -> Scope Mismatch. False.

[DepBetween] Checking dependency...
  Vec A Size: 1
  Vec B Size: 1
  [MemAlias Check]
    Root A: OpResult defined by [arith.constant] | Type: i64
    Root B: OpResult defined by [arith.constant] | Type: i64
    Scope A: 2, Scope B: 5
    -> Scope Mismatch. False.
  -> No Dependency.

[MemAnalyze] Analyzing Dependency:
  Now Node: pto.load_dps
    DefVec (Size 1):
 - Root: arith.constant | Scope: 2
    UseVec (Size 1):
 - Root: BlockArg | Scope: 1
  Front Node: pto.mov_dps
    DefVec (Size 1):
 - Root: arith.constant | Scope: 4
    UseVec (Size 1):
 - Root: arith.constant | Scope: 2
  -> Already Synced at Pipe Level. Skipping.

[MemAnalyze] Analyzing Dependency:
  Now Node: pto.load_dps
    DefVec (Size 1):
 - Root: arith.constant | Scope: 2
    UseVec (Size 1):
 - Root: BlockArg | Scope: 1
  Front Node: pto.mov_dps
    DefVec (Size 1):
 - Root: arith.constant | Scope: 3
    UseVec (Size 1):
 - Root: arith.constant | Scope: 2
  -> Already Synced at Pipe Level. Skipping.

[MemAnalyze] Analyzing Dependency:
  Now Node: pto.load_dps
    DefVec (Size 1):
 - Root: arith.constant | Scope: 2
    UseVec (Size 1):
 - Root: BlockArg | Scope: 1
  Front Node: pto.load_dps
    DefVec (Size 1):
 - Root: arith.constant | Scope: 2
    UseVec (Size 1):
 - Root: BlockArg | Scope: 1

[DepBetween] Checking dependency...
  Vec A Size: 1
  Vec B Size: 1
  [MemAlias Check]
    Root A: BlockArgument | Type: memref<?xf16, #pto.address_space<gm>>
    Root B: OpResult defined by [arith.constant] | Type: i64
    Scope A: 1, Scope B: 2
    -> Scope Mismatch. False.

[DepBetween] Checking dependency...
  Vec A Size: 1
  Vec B Size: 1
  [MemAlias Check]
    Root A: OpResult defined by [arith.constant] | Type: i64
    Root B: BlockArgument | Type: memref<?xf16, #pto.address_space<gm>>
    Scope A: 2, Scope B: 1
    -> Scope Mismatch. False.

[DepBetween] Checking dependency...
  Vec A Size: 1
  Vec B Size: 1
  [MemAlias Check]
    Root A: OpResult defined by [arith.constant] | Type: i64
    Root B: OpResult defined by [arith.constant] | Type: i64
    Scope A: 2, Scope B: 2
  -> Dependency FOUND!
  -> Intra-Pipe dep on Local Mem (No GM). Skipping Barrier.

[MemAnalyze] Analyzing Dependency:
  Now Node: pto.load_dps
    DefVec (Size 1):
 - Root: arith.constant | Scope: 2
    UseVec (Size 1):
 - Root: BlockArg | Scope: 1
  Front Node: pto.load_dps
    DefVec (Size 1):
 - Root: arith.constant | Scope: 2
    UseVec (Size 1):
 - Root: BlockArg | Scope: 1

[DepBetween] Checking dependency...
  Vec A Size: 1
  Vec B Size: 1
  [MemAlias Check]
    Root A: BlockArgument | Type: memref<?xf16, #pto.address_space<gm>>
    Root B: OpResult defined by [arith.constant] | Type: i64
    Scope A: 1, Scope B: 2
    -> Scope Mismatch. False.

[DepBetween] Checking dependency...
  Vec A Size: 1
  Vec B Size: 1
  [MemAlias Check]
    Root A: OpResult defined by [arith.constant] | Type: i64
    Root B: BlockArgument | Type: memref<?xf16, #pto.address_space<gm>>
    Scope A: 2, Scope B: 1
    -> Scope Mismatch. False.

[DepBetween] Checking dependency...
  Vec A Size: 1
  Vec B Size: 1
  [MemAlias Check]
    Root A: OpResult defined by [arith.constant] | Type: i64
    Root B: OpResult defined by [arith.constant] | Type: i64
    Scope A: 2, Scope B: 2
  [Trace] GetRealRoot Start:
    Current: OpResult defined by [arith.constant] | Type: i64
    -> Hit Alloc/Other [arith.constant]. Stop.
  [Trace] GetRealRoot Start:
    Current: OpResult defined by [arith.constant] | Type: i64
    -> Hit Alloc/Other [arith.constant]. Stop.
    [Deep Check] Surface Roots differ. Digging deeper...
      Real Root A: OpResult defined by [arith.constant] | Type: i64
      Real Root B: OpResult defined by [arith.constant] | Type: i64
      -> Mismatch. Real roots differ.
  -> No Dependency.

[MemAnalyze] Analyzing Dependency:
  Now Node: pto.mov_dps
    DefVec (Size 1):
 - Root: arith.constant | Scope: 3
    UseVec (Size 1):
 - Root: arith.constant | Scope: 2
  Front Node: pto.store_dps
    DefVec (Size 1):
 - Root: BlockArg | Scope: 1
    UseVec (Size 1):
 - Root: arith.constant | Scope: 5

[DepBetween] Checking dependency...
  Vec A Size: 1
  Vec B Size: 1
  [MemAlias Check]
    Root A: OpResult defined by [arith.constant] | Type: i64
    Root B: BlockArgument | Type: memref<?xf32, #pto.address_space<gm>>
    Scope A: 2, Scope B: 1
    -> Scope Mismatch. False.

[DepBetween] Checking dependency...
  Vec A Size: 1
  Vec B Size: 1
  [MemAlias Check]
    Root A: OpResult defined by [arith.constant] | Type: i64
    Root B: OpResult defined by [arith.constant] | Type: i64
    Scope A: 3, Scope B: 5
    -> Scope Mismatch. False.

[DepBetween] Checking dependency...
  Vec A Size: 1
  Vec B Size: 1
  [MemAlias Check]
    Root A: OpResult defined by [arith.constant] | Type: i64
    Root B: BlockArgument | Type: memref<?xf32, #pto.address_space<gm>>
    Scope A: 3, Scope B: 1
    -> Scope Mismatch. False.
  -> No Dependency.

[MemAnalyze] Analyzing Dependency:
  Now Node: pto.mov_dps
    DefVec (Size 1):
 - Root: arith.constant | Scope: 3
    UseVec (Size 1):
 - Root: arith.constant | Scope: 2
  Front Node: pto.mov_dps
    DefVec (Size 1):
 - Root: arith.constant | Scope: 4
    UseVec (Size 1):
 - Root: arith.constant | Scope: 2
  -> Already Synced at Pipe Level. Skipping.

[MemAnalyze] Analyzing Dependency:
  Now Node: pto.mov_dps
    DefVec (Size 1):
 - Root: arith.constant | Scope: 3
    UseVec (Size 1):
 - Root: arith.constant | Scope: 2
  Front Node: pto.mov_dps
    DefVec (Size 1):
 - Root: arith.constant | Scope: 3
    UseVec (Size 1):
 - Root: arith.constant | Scope: 2
  -> Already Synced at Pipe Level. Skipping.

[MemAnalyze] Analyzing Dependency:
  Now Node: pto.mov_dps
    DefVec (Size 1):
 - Root: arith.constant | Scope: 3
    UseVec (Size 1):
 - Root: arith.constant | Scope: 2
  Front Node: pto.load_dps
    DefVec (Size 1):
 - Root: arith.constant | Scope: 2
    UseVec (Size 1):
 - Root: BlockArg | Scope: 1
  -> Already Synced at Pipe Level. Skipping.

[MemAnalyze] Analyzing Dependency:
  Now Node: pto.mov_dps
    DefVec (Size 1):
 - Root: arith.constant | Scope: 3
    UseVec (Size 1):
 - Root: arith.constant | Scope: 2
  Front Node: pto.load_dps
    DefVec (Size 1):
 - Root: arith.constant | Scope: 2
    UseVec (Size 1):
 - Root: BlockArg | Scope: 1
  -> Already Synced at Pipe Level. Skipping.

[MemAnalyze] Analyzing Dependency:
  Now Node: pto.mov_dps
    DefVec (Size 1):
 - Root: arith.constant | Scope: 3
    UseVec (Size 1):
 - Root: arith.constant | Scope: 2
  Front Node: pto.matmul_dps
    DefVec (Size 1):
 - Root: arith.constant | Scope: 5
    UseVec (Size 2):
 - Root: arith.constant | Scope: 3
 - Root: arith.constant | Scope: 4
  -> Already Synced at Pipe Level. Skipping.

[MemAnalyze] Analyzing Dependency:
  Now Node: pto.mov_dps
    DefVec (Size 1):
 - Root: arith.constant | Scope: 3
    UseVec (Size 1):
 - Root: arith.constant | Scope: 2
  Front Node: pto.mov_dps
    DefVec (Size 1):
 - Root: arith.constant | Scope: 4
    UseVec (Size 1):
 - Root: arith.constant | Scope: 2
  -> Already Synced at Pipe Level. Skipping.

[MemAnalyze] Analyzing Dependency:
  Now Node: pto.mov_dps
    DefVec (Size 1):
 - Root: arith.constant | Scope: 3
    UseVec (Size 1):
 - Root: arith.constant | Scope: 2
  Front Node: pto.mov_dps
    DefVec (Size 1):
 - Root: arith.constant | Scope: 3
    UseVec (Size 1):
 - Root: arith.constant | Scope: 2
  -> Already Synced at Pipe Level. Skipping.

[MemAnalyze] Analyzing Dependency:
  Now Node: pto.mov_dps
    DefVec (Size 1):
 - Root: arith.constant | Scope: 3
    UseVec (Size 1):
 - Root: arith.constant | Scope: 2
  Front Node: pto.load_dps
    DefVec (Size 1):
 - Root: arith.constant | Scope: 2
    UseVec (Size 1):
 - Root: BlockArg | Scope: 1
  -> Already Synced at Pipe Level. Skipping.

[MemAnalyze] Analyzing Dependency:
  Now Node: pto.mov_dps
    DefVec (Size 1):
 - Root: arith.constant | Scope: 3
    UseVec (Size 1):
 - Root: arith.constant | Scope: 2
  Front Node: pto.load_dps
    DefVec (Size 1):
 - Root: arith.constant | Scope: 2
    UseVec (Size 1):
 - Root: BlockArg | Scope: 1
  -> Already Synced at Pipe Level. Skipping.

[MemAnalyze] Analyzing Dependency:
  Now Node: pto.mov_dps
    DefVec (Size 1):
 - Root: arith.constant | Scope: 4
    UseVec (Size 1):
 - Root: arith.constant | Scope: 2
  Front Node: pto.store_dps
    DefVec (Size 1):
 - Root: BlockArg | Scope: 1
    UseVec (Size 1):
 - Root: arith.constant | Scope: 5

[DepBetween] Checking dependency...
  Vec A Size: 1
  Vec B Size: 1
  [MemAlias Check]
    Root A: OpResult defined by [arith.constant] | Type: i64
    Root B: BlockArgument | Type: memref<?xf32, #pto.address_space<gm>>
    Scope A: 2, Scope B: 1
    -> Scope Mismatch. False.

[DepBetween] Checking dependency...
  Vec A Size: 1
  Vec B Size: 1
  [MemAlias Check]
    Root A: OpResult defined by [arith.constant] | Type: i64
    Root B: OpResult defined by [arith.constant] | Type: i64
    Scope A: 4, Scope B: 5
    -> Scope Mismatch. False.

[DepBetween] Checking dependency...
  Vec A Size: 1
  Vec B Size: 1
  [MemAlias Check]
    Root A: OpResult defined by [arith.constant] | Type: i64
    Root B: BlockArgument | Type: memref<?xf32, #pto.address_space<gm>>
    Scope A: 4, Scope B: 1
    -> Scope Mismatch. False.
  -> No Dependency.

[MemAnalyze] Analyzing Dependency:
  Now Node: pto.mov_dps
    DefVec (Size 1):
 - Root: arith.constant | Scope: 4
    UseVec (Size 1):
 - Root: arith.constant | Scope: 2
  Front Node: pto.mov_dps
    DefVec (Size 1):
 - Root: arith.constant | Scope: 4
    UseVec (Size 1):
 - Root: arith.constant | Scope: 2
  -> Already Synced at Pipe Level. Skipping.

[MemAnalyze] Analyzing Dependency:
  Now Node: pto.mov_dps
    DefVec (Size 1):
 - Root: arith.constant | Scope: 4
    UseVec (Size 1):
 - Root: arith.constant | Scope: 2
  Front Node: pto.mov_dps
    DefVec (Size 1):
 - Root: arith.constant | Scope: 3
    UseVec (Size 1):
 - Root: arith.constant | Scope: 2
  -> Already Synced at Pipe Level. Skipping.

[MemAnalyze] Analyzing Dependency:
  Now Node: pto.mov_dps
    DefVec (Size 1):
 - Root: arith.constant | Scope: 4
    UseVec (Size 1):
 - Root: arith.constant | Scope: 2
  Front Node: pto.load_dps
    DefVec (Size 1):
 - Root: arith.constant | Scope: 2
    UseVec (Size 1):
 - Root: BlockArg | Scope: 1
  -> Already Synced at Pipe Level. Skipping.

[MemAnalyze] Analyzing Dependency:
  Now Node: pto.mov_dps
    DefVec (Size 1):
 - Root: arith.constant | Scope: 4
    UseVec (Size 1):
 - Root: arith.constant | Scope: 2
  Front Node: pto.load_dps
    DefVec (Size 1):
 - Root: arith.constant | Scope: 2
    UseVec (Size 1):
 - Root: BlockArg | Scope: 1
  -> Already Synced at Pipe Level. Skipping.

[MemAnalyze] Analyzing Dependency:
  Now Node: pto.mov_dps
    DefVec (Size 1):
 - Root: arith.constant | Scope: 4
    UseVec (Size 1):
 - Root: arith.constant | Scope: 2
  Front Node: pto.matmul_dps
    DefVec (Size 1):
 - Root: arith.constant | Scope: 5
    UseVec (Size 2):
 - Root: arith.constant | Scope: 3
 - Root: arith.constant | Scope: 4
  -> Already Synced at Pipe Level. Skipping.

[MemAnalyze] Analyzing Dependency:
  Now Node: pto.mov_dps
    DefVec (Size 1):
 - Root: arith.constant | Scope: 4
    UseVec (Size 1):
 - Root: arith.constant | Scope: 2
  Front Node: pto.mov_dps
    DefVec (Size 1):
 - Root: arith.constant | Scope: 4
    UseVec (Size 1):
 - Root: arith.constant | Scope: 2
  -> Already Synced at Pipe Level. Skipping.

[MemAnalyze] Analyzing Dependency:
  Now Node: pto.mov_dps
    DefVec (Size 1):
 - Root: arith.constant | Scope: 4
    UseVec (Size 1):
 - Root: arith.constant | Scope: 2
  Front Node: pto.mov_dps
    DefVec (Size 1):
 - Root: arith.constant | Scope: 3
    UseVec (Size 1):
 - Root: arith.constant | Scope: 2
  -> Already Synced at Pipe Level. Skipping.

[MemAnalyze] Analyzing Dependency:
  Now Node: pto.mov_dps
    DefVec (Size 1):
 - Root: arith.constant | Scope: 4
    UseVec (Size 1):
 - Root: arith.constant | Scope: 2
  Front Node: pto.load_dps
    DefVec (Size 1):
 - Root: arith.constant | Scope: 2
    UseVec (Size 1):
 - Root: BlockArg | Scope: 1
  -> Already Synced at Pipe Level. Skipping.

[MemAnalyze] Analyzing Dependency:
  Now Node: pto.mov_dps
    DefVec (Size 1):
 - Root: arith.constant | Scope: 4
    UseVec (Size 1):
 - Root: arith.constant | Scope: 2
  Front Node: pto.load_dps
    DefVec (Size 1):
 - Root: arith.constant | Scope: 2
    UseVec (Size 1):
 - Root: BlockArg | Scope: 1
  -> Already Synced at Pipe Level. Skipping.

[MemAnalyze] Analyzing Dependency:
  Now Node: pto.matmul_dps
    DefVec (Size 1):
 - Root: arith.constant | Scope: 5
    UseVec (Size 2):
 - Root: arith.constant | Scope: 3
 - Root: arith.constant | Scope: 4
  Front Node: pto.store_dps
    DefVec (Size 1):
 - Root: BlockArg | Scope: 1
    UseVec (Size 1):
 - Root: arith.constant | Scope: 5
  -> Already Synced at Pipe Level. Skipping.

[MemAnalyze] Analyzing Dependency:
  Now Node: pto.matmul_dps
    DefVec (Size 1):
 - Root: arith.constant | Scope: 5
    UseVec (Size 2):
 - Root: arith.constant | Scope: 3
 - Root: arith.constant | Scope: 4
  Front Node: pto.mov_dps
    DefVec (Size 1):
 - Root: arith.constant | Scope: 4
    UseVec (Size 1):
 - Root: arith.constant | Scope: 2
  -> Already Synced at Pipe Level. Skipping.

[MemAnalyze] Analyzing Dependency:
  Now Node: pto.matmul_dps
    DefVec (Size 1):
 - Root: arith.constant | Scope: 5
    UseVec (Size 2):
 - Root: arith.constant | Scope: 3
 - Root: arith.constant | Scope: 4
  Front Node: pto.mov_dps
    DefVec (Size 1):
 - Root: arith.constant | Scope: 3
    UseVec (Size 1):
 - Root: arith.constant | Scope: 2
  -> Already Synced at Pipe Level. Skipping.

[MemAnalyze] Analyzing Dependency:
  Now Node: pto.matmul_dps
    DefVec (Size 1):
 - Root: arith.constant | Scope: 5
    UseVec (Size 2):
 - Root: arith.constant | Scope: 3
 - Root: arith.constant | Scope: 4
  Front Node: pto.load_dps
    DefVec (Size 1):
 - Root: arith.constant | Scope: 2
    UseVec (Size 1):
 - Root: BlockArg | Scope: 1
  -> Already Synced at Pipe Level. Skipping.

[MemAnalyze] Analyzing Dependency:
  Now Node: pto.matmul_dps
    DefVec (Size 1):
 - Root: arith.constant | Scope: 5
    UseVec (Size 2):
 - Root: arith.constant | Scope: 3
 - Root: arith.constant | Scope: 4
  Front Node: pto.load_dps
    DefVec (Size 1):
 - Root: arith.constant | Scope: 2
    UseVec (Size 1):
 - Root: BlockArg | Scope: 1
  -> Already Synced at Pipe Level. Skipping.

[MemAnalyze] Analyzing Dependency:
  Now Node: pto.matmul_dps
    DefVec (Size 1):
 - Root: arith.constant | Scope: 5
    UseVec (Size 2):
 - Root: arith.constant | Scope: 3
 - Root: arith.constant | Scope: 4
  Front Node: pto.matmul_dps
    DefVec (Size 1):
 - Root: arith.constant | Scope: 5
    UseVec (Size 2):
 - Root: arith.constant | Scope: 3
 - Root: arith.constant | Scope: 4
  -> Already Synced at Pipe Level. Skipping.

[MemAnalyze] Analyzing Dependency:
  Now Node: pto.matmul_dps
    DefVec (Size 1):
 - Root: arith.constant | Scope: 5
    UseVec (Size 2):
 - Root: arith.constant | Scope: 3
 - Root: arith.constant | Scope: 4
  Front Node: pto.mov_dps
    DefVec (Size 1):
 - Root: arith.constant | Scope: 4
    UseVec (Size 1):
 - Root: arith.constant | Scope: 2
  -> Already Synced at Pipe Level. Skipping.

[MemAnalyze] Analyzing Dependency:
  Now Node: pto.matmul_dps
    DefVec (Size 1):
 - Root: arith.constant | Scope: 5
    UseVec (Size 2):
 - Root: arith.constant | Scope: 3
 - Root: arith.constant | Scope: 4
  Front Node: pto.mov_dps
    DefVec (Size 1):
 - Root: arith.constant | Scope: 3
    UseVec (Size 1):
 - Root: arith.constant | Scope: 2
  -> Already Synced at Pipe Level. Skipping.

[MemAnalyze] Analyzing Dependency:
  Now Node: pto.matmul_dps
    DefVec (Size 1):
 - Root: arith.constant | Scope: 5
    UseVec (Size 2):
 - Root: arith.constant | Scope: 3
 - Root: arith.constant | Scope: 4
  Front Node: pto.load_dps
    DefVec (Size 1):
 - Root: arith.constant | Scope: 2
    UseVec (Size 1):
 - Root: BlockArg | Scope: 1
  -> Already Synced at Pipe Level. Skipping.

[MemAnalyze] Analyzing Dependency:
  Now Node: pto.matmul_dps
    DefVec (Size 1):
 - Root: arith.constant | Scope: 5
    UseVec (Size 2):
 - Root: arith.constant | Scope: 3
 - Root: arith.constant | Scope: 4
  Front Node: pto.load_dps
    DefVec (Size 1):
 - Root: arith.constant | Scope: 2
    UseVec (Size 1):
 - Root: BlockArg | Scope: 1
  -> Already Synced at Pipe Level. Skipping.

[MemAnalyze] Analyzing Dependency:
  Now Node: pto.load_dps
    DefVec (Size 1):
 - Root: arith.constant | Scope: 2
    UseVec (Size 1):
 - Root: BlockArg | Scope: 1
  Front Node: pto.store_dps
    DefVec (Size 1):
 - Root: BlockArg | Scope: 1
    UseVec (Size 1):
 - Root: arith.constant | Scope: 5
  -> Already Synced at Pipe Level. Skipping.

[MemAnalyze] Analyzing Dependency:
  Now Node: pto.load_dps
    DefVec (Size 1):
 - Root: arith.constant | Scope: 2
    UseVec (Size 1):
 - Root: BlockArg | Scope: 1
  Front Node: pto.mov_dps
    DefVec (Size 1):
 - Root: arith.constant | Scope: 4
    UseVec (Size 1):
 - Root: arith.constant | Scope: 2
  -> Already Synced at Pipe Level. Skipping.

[MemAnalyze] Analyzing Dependency:
  Now Node: pto.load_dps
    DefVec (Size 1):
 - Root: arith.constant | Scope: 2
    UseVec (Size 1):
 - Root: BlockArg | Scope: 1
  Front Node: pto.mov_dps
    DefVec (Size 1):
 - Root: arith.constant | Scope: 3
    UseVec (Size 1):
 - Root: arith.constant | Scope: 2
  -> Already Synced at Pipe Level. Skipping.

[MemAnalyze] Analyzing Dependency:
  Now Node: pto.load_dps
    DefVec (Size 1):
 - Root: arith.constant | Scope: 2
    UseVec (Size 1):
 - Root: BlockArg | Scope: 1
  Front Node: pto.load_dps
    DefVec (Size 1):
 - Root: arith.constant | Scope: 2
    UseVec (Size 1):
 - Root: BlockArg | Scope: 1
  -> Already Synced at Pipe Level. Skipping.

[MemAnalyze] Analyzing Dependency:
  Now Node: pto.load_dps
    DefVec (Size 1):
 - Root: arith.constant | Scope: 2
    UseVec (Size 1):
 - Root: BlockArg | Scope: 1
  Front Node: pto.load_dps
    DefVec (Size 1):
 - Root: arith.constant | Scope: 2
    UseVec (Size 1):
 - Root: BlockArg | Scope: 1
  -> Already Synced at Pipe Level. Skipping.

[MemAnalyze] Analyzing Dependency:
  Now Node: pto.load_dps
    DefVec (Size 1):
 - Root: arith.constant | Scope: 2
    UseVec (Size 1):
 - Root: BlockArg | Scope: 1
  Front Node: pto.matmul_dps
    DefVec (Size 1):
 - Root: arith.constant | Scope: 5
    UseVec (Size 2):
 - Root: arith.constant | Scope: 3
 - Root: arith.constant | Scope: 4
  -> Already Synced at Pipe Level. Skipping.

[MemAnalyze] Analyzing Dependency:
  Now Node: pto.load_dps
    DefVec (Size 1):
 - Root: arith.constant | Scope: 2
    UseVec (Size 1):
 - Root: BlockArg | Scope: 1
  Front Node: pto.mov_dps
    DefVec (Size 1):
 - Root: arith.constant | Scope: 4
    UseVec (Size 1):
 - Root: arith.constant | Scope: 2
  -> Already Synced at Pipe Level. Skipping.

[MemAnalyze] Analyzing Dependency:
  Now Node: pto.load_dps
    DefVec (Size 1):
 - Root: arith.constant | Scope: 2
    UseVec (Size 1):
 - Root: BlockArg | Scope: 1
  Front Node: pto.mov_dps
    DefVec (Size 1):
 - Root: arith.constant | Scope: 3
    UseVec (Size 1):
 - Root: arith.constant | Scope: 2
  -> Already Synced at Pipe Level. Skipping.

[MemAnalyze] Analyzing Dependency:
  Now Node: pto.load_dps
    DefVec (Size 1):
 - Root: arith.constant | Scope: 2
    UseVec (Size 1):
 - Root: BlockArg | Scope: 1
  Front Node: pto.load_dps
    DefVec (Size 1):
 - Root: arith.constant | Scope: 2
    UseVec (Size 1):
 - Root: BlockArg | Scope: 1
  -> Already Synced at Pipe Level. Skipping.

[MemAnalyze] Analyzing Dependency:
  Now Node: pto.load_dps
    DefVec (Size 1):
 - Root: arith.constant | Scope: 2
    UseVec (Size 1):
 - Root: BlockArg | Scope: 1
  Front Node: pto.load_dps
    DefVec (Size 1):
 - Root: arith.constant | Scope: 2
    UseVec (Size 1):
 - Root: BlockArg | Scope: 1
  -> Already Synced at Pipe Level. Skipping.

[MemAnalyze] Analyzing Dependency:
  Now Node: pto.load_dps
    DefVec (Size 1):
 - Root: arith.constant | Scope: 2
    UseVec (Size 1):
 - Root: BlockArg | Scope: 1
  Front Node: pto.store_dps
    DefVec (Size 1):
 - Root: BlockArg | Scope: 1
    UseVec (Size 1):
 - Root: arith.constant | Scope: 5
  -> Already Synced at Pipe Level. Skipping.

[MemAnalyze] Analyzing Dependency:
  Now Node: pto.load_dps
    DefVec (Size 1):
 - Root: arith.constant | Scope: 2
    UseVec (Size 1):
 - Root: BlockArg | Scope: 1
  Front Node: pto.mov_dps
    DefVec (Size 1):
 - Root: arith.constant | Scope: 4
    UseVec (Size 1):
 - Root: arith.constant | Scope: 2
  -> Already Synced at Pipe Level. Skipping.

[MemAnalyze] Analyzing Dependency:
  Now Node: pto.load_dps
    DefVec (Size 1):
 - Root: arith.constant | Scope: 2
    UseVec (Size 1):
 - Root: BlockArg | Scope: 1
  Front Node: pto.mov_dps
    DefVec (Size 1):
 - Root: arith.constant | Scope: 3
    UseVec (Size 1):
 - Root: arith.constant | Scope: 2
  -> Already Synced at Pipe Level. Skipping.

[MemAnalyze] Analyzing Dependency:
  Now Node: pto.load_dps
    DefVec (Size 1):
 - Root: arith.constant | Scope: 2
    UseVec (Size 1):
 - Root: BlockArg | Scope: 1
  Front Node: pto.load_dps
    DefVec (Size 1):
 - Root: arith.constant | Scope: 2
    UseVec (Size 1):
 - Root: BlockArg | Scope: 1
  -> Already Synced at Pipe Level. Skipping.

[MemAnalyze] Analyzing Dependency:
  Now Node: pto.load_dps
    DefVec (Size 1):
 - Root: arith.constant | Scope: 2
    UseVec (Size 1):
 - Root: BlockArg | Scope: 1
  Front Node: pto.load_dps
    DefVec (Size 1):
 - Root: arith.constant | Scope: 2
    UseVec (Size 1):
 - Root: BlockArg | Scope: 1
  -> Already Synced at Pipe Level. Skipping.

[MemAnalyze] Analyzing Dependency:
  Now Node: pto.load_dps
    DefVec (Size 1):
 - Root: arith.constant | Scope: 2
    UseVec (Size 1):
 - Root: BlockArg | Scope: 1
  Front Node: pto.matmul_dps
    DefVec (Size 1):
 - Root: arith.constant | Scope: 5
    UseVec (Size 2):
 - Root: arith.constant | Scope: 3
 - Root: arith.constant | Scope: 4
  -> Already Synced at Pipe Level. Skipping.

[MemAnalyze] Analyzing Dependency:
  Now Node: pto.load_dps
    DefVec (Size 1):
 - Root: arith.constant | Scope: 2
    UseVec (Size 1):
 - Root: BlockArg | Scope: 1
  Front Node: pto.mov_dps
    DefVec (Size 1):
 - Root: arith.constant | Scope: 4
    UseVec (Size 1):
 - Root: arith.constant | Scope: 2
  -> Already Synced at Pipe Level. Skipping.

[MemAnalyze] Analyzing Dependency:
  Now Node: pto.load_dps
    DefVec (Size 1):
 - Root: arith.constant | Scope: 2
    UseVec (Size 1):
 - Root: BlockArg | Scope: 1
  Front Node: pto.mov_dps
    DefVec (Size 1):
 - Root: arith.constant | Scope: 3
    UseVec (Size 1):
 - Root: arith.constant | Scope: 2
  -> Already Synced at Pipe Level. Skipping.

[MemAnalyze] Analyzing Dependency:
  Now Node: pto.load_dps
    DefVec (Size 1):
 - Root: arith.constant | Scope: 2
    UseVec (Size 1):
 - Root: BlockArg | Scope: 1
  Front Node: pto.load_dps
    DefVec (Size 1):
 - Root: arith.constant | Scope: 2
    UseVec (Size 1):
 - Root: BlockArg | Scope: 1
  -> Already Synced at Pipe Level. Skipping.

[MemAnalyze] Analyzing Dependency:
  Now Node: pto.load_dps
    DefVec (Size 1):
 - Root: arith.constant | Scope: 2
    UseVec (Size 1):
 - Root: BlockArg | Scope: 1
  Front Node: pto.load_dps
    DefVec (Size 1):
 - Root: arith.constant | Scope: 2
    UseVec (Size 1):
 - Root: BlockArg | Scope: 1
  -> Already Synced at Pipe Level. Skipping.

[MemAnalyze] Analyzing Dependency:
  Now Node: pto.mov_dps
    DefVec (Size 1):
 - Root: arith.constant | Scope: 3
    UseVec (Size 1):
 - Root: arith.constant | Scope: 2
  Front Node: pto.store_dps
    DefVec (Size 1):
 - Root: BlockArg | Scope: 1
    UseVec (Size 1):
 - Root: arith.constant | Scope: 5
  -> Already Synced at Pipe Level. Skipping.

[MemAnalyze] Analyzing Dependency:
  Now Node: pto.mov_dps
    DefVec (Size 1):
 - Root: arith.constant | Scope: 3
    UseVec (Size 1):
 - Root: arith.constant | Scope: 2
  Front Node: pto.mov_dps
    DefVec (Size 1):
 - Root: arith.constant | Scope: 4
    UseVec (Size 1):
 - Root: arith.constant | Scope: 2
  -> Already Synced at Pipe Level. Skipping.

[MemAnalyze] Analyzing Dependency:
  Now Node: pto.mov_dps
    DefVec (Size 1):
 - Root: arith.constant | Scope: 3
    UseVec (Size 1):
 - Root: arith.constant | Scope: 2
  Front Node: pto.mov_dps
    DefVec (Size 1):
 - Root: arith.constant | Scope: 3
    UseVec (Size 1):
 - Root: arith.constant | Scope: 2
  -> Already Synced at Pipe Level. Skipping.

[MemAnalyze] Analyzing Dependency:
  Now Node: pto.mov_dps
    DefVec (Size 1):
 - Root: arith.constant | Scope: 3
    UseVec (Size 1):
 - Root: arith.constant | Scope: 2
  Front Node: pto.load_dps
    DefVec (Size 1):
 - Root: arith.constant | Scope: 2
    UseVec (Size 1):
 - Root: BlockArg | Scope: 1
  -> Already Synced at Pipe Level. Skipping.

[MemAnalyze] Analyzing Dependency:
  Now Node: pto.mov_dps
    DefVec (Size 1):
 - Root: arith.constant | Scope: 3
    UseVec (Size 1):
 - Root: arith.constant | Scope: 2
  Front Node: pto.load_dps
    DefVec (Size 1):
 - Root: arith.constant | Scope: 2
    UseVec (Size 1):
 - Root: BlockArg | Scope: 1
  -> Already Synced at Pipe Level. Skipping.

[MemAnalyze] Analyzing Dependency:
  Now Node: pto.mov_dps
    DefVec (Size 1):
 - Root: arith.constant | Scope: 3
    UseVec (Size 1):
 - Root: arith.constant | Scope: 2
  Front Node: pto.matmul_dps
    DefVec (Size 1):
 - Root: arith.constant | Scope: 5
    UseVec (Size 2):
 - Root: arith.constant | Scope: 3
 - Root: arith.constant | Scope: 4
  -> Already Synced at Pipe Level. Skipping.

[MemAnalyze] Analyzing Dependency:
  Now Node: pto.mov_dps
    DefVec (Size 1):
 - Root: arith.constant | Scope: 3
    UseVec (Size 1):
 - Root: arith.constant | Scope: 2
  Front Node: pto.mov_dps
    DefVec (Size 1):
 - Root: arith.constant | Scope: 4
    UseVec (Size 1):
 - Root: arith.constant | Scope: 2
  -> Already Synced at Pipe Level. Skipping.

[MemAnalyze] Analyzing Dependency:
  Now Node: pto.mov_dps
    DefVec (Size 1):
 - Root: arith.constant | Scope: 3
    UseVec (Size 1):
 - Root: arith.constant | Scope: 2
  Front Node: pto.mov_dps
    DefVec (Size 1):
 - Root: arith.constant | Scope: 3
    UseVec (Size 1):
 - Root: arith.constant | Scope: 2
  -> Already Synced at Pipe Level. Skipping.

[MemAnalyze] Analyzing Dependency:
  Now Node: pto.mov_dps
    DefVec (Size 1):
 - Root: arith.constant | Scope: 3
    UseVec (Size 1):
 - Root: arith.constant | Scope: 2
  Front Node: pto.load_dps
    DefVec (Size 1):
 - Root: arith.constant | Scope: 2
    UseVec (Size 1):
 - Root: BlockArg | Scope: 1
  -> Already Synced at Pipe Level. Skipping.

[MemAnalyze] Analyzing Dependency:
  Now Node: pto.mov_dps
    DefVec (Size 1):
 - Root: arith.constant | Scope: 3
    UseVec (Size 1):
 - Root: arith.constant | Scope: 2
  Front Node: pto.load_dps
    DefVec (Size 1):
 - Root: arith.constant | Scope: 2
    UseVec (Size 1):
 - Root: BlockArg | Scope: 1
  -> Already Synced at Pipe Level. Skipping.

[MemAnalyze] Analyzing Dependency:
  Now Node: pto.mov_dps
    DefVec (Size 1):
 - Root: arith.constant | Scope: 4
    UseVec (Size 1):
 - Root: arith.constant | Scope: 2
  Front Node: pto.store_dps
    DefVec (Size 1):
 - Root: BlockArg | Scope: 1
    UseVec (Size 1):
 - Root: arith.constant | Scope: 5
  -> Already Synced at Pipe Level. Skipping.

[MemAnalyze] Analyzing Dependency:
  Now Node: pto.mov_dps
    DefVec (Size 1):
 - Root: arith.constant | Scope: 4
    UseVec (Size 1):
 - Root: arith.constant | Scope: 2
  Front Node: pto.mov_dps
    DefVec (Size 1):
 - Root: arith.constant | Scope: 4
    UseVec (Size 1):
 - Root: arith.constant | Scope: 2
  -> Already Synced at Pipe Level. Skipping.

[MemAnalyze] Analyzing Dependency:
  Now Node: pto.mov_dps
    DefVec (Size 1):
 - Root: arith.constant | Scope: 4
    UseVec (Size 1):
 - Root: arith.constant | Scope: 2
  Front Node: pto.mov_dps
    DefVec (Size 1):
 - Root: arith.constant | Scope: 3
    UseVec (Size 1):
 - Root: arith.constant | Scope: 2
  -> Already Synced at Pipe Level. Skipping.

[MemAnalyze] Analyzing Dependency:
  Now Node: pto.mov_dps
    DefVec (Size 1):
 - Root: arith.constant | Scope: 4
    UseVec (Size 1):
 - Root: arith.constant | Scope: 2
  Front Node: pto.load_dps
    DefVec (Size 1):
 - Root: arith.constant | Scope: 2
    UseVec (Size 1):
 - Root: BlockArg | Scope: 1
  -> Already Synced at Pipe Level. Skipping.

[MemAnalyze] Analyzing Dependency:
  Now Node: pto.mov_dps
    DefVec (Size 1):
 - Root: arith.constant | Scope: 4
    UseVec (Size 1):
 - Root: arith.constant | Scope: 2
  Front Node: pto.load_dps
    DefVec (Size 1):
 - Root: arith.constant | Scope: 2
    UseVec (Size 1):
 - Root: BlockArg | Scope: 1
  -> Already Synced at Pipe Level. Skipping.

[MemAnalyze] Analyzing Dependency:
  Now Node: pto.mov_dps
    DefVec (Size 1):
 - Root: arith.constant | Scope: 4
    UseVec (Size 1):
 - Root: arith.constant | Scope: 2
  Front Node: pto.matmul_dps
    DefVec (Size 1):
 - Root: arith.constant | Scope: 5
    UseVec (Size 2):
 - Root: arith.constant | Scope: 3
 - Root: arith.constant | Scope: 4
  -> Already Synced at Pipe Level. Skipping.

[MemAnalyze] Analyzing Dependency:
  Now Node: pto.mov_dps
    DefVec (Size 1):
 - Root: arith.constant | Scope: 4
    UseVec (Size 1):
 - Root: arith.constant | Scope: 2
  Front Node: pto.mov_dps
    DefVec (Size 1):
 - Root: arith.constant | Scope: 4
    UseVec (Size 1):
 - Root: arith.constant | Scope: 2
  -> Already Synced at Pipe Level. Skipping.

[MemAnalyze] Analyzing Dependency:
  Now Node: pto.mov_dps
    DefVec (Size 1):
 - Root: arith.constant | Scope: 4
    UseVec (Size 1):
 - Root: arith.constant | Scope: 2
  Front Node: pto.mov_dps
    DefVec (Size 1):
 - Root: arith.constant | Scope: 3
    UseVec (Size 1):
 - Root: arith.constant | Scope: 2
  -> Already Synced at Pipe Level. Skipping.

[MemAnalyze] Analyzing Dependency:
  Now Node: pto.mov_dps
    DefVec (Size 1):
 - Root: arith.constant | Scope: 4
    UseVec (Size 1):
 - Root: arith.constant | Scope: 2
  Front Node: pto.load_dps
    DefVec (Size 1):
 - Root: arith.constant | Scope: 2
    UseVec (Size 1):
 - Root: BlockArg | Scope: 1
  -> Already Synced at Pipe Level. Skipping.

[MemAnalyze] Analyzing Dependency:
  Now Node: pto.mov_dps
    DefVec (Size 1):
 - Root: arith.constant | Scope: 4
    UseVec (Size 1):
 - Root: arith.constant | Scope: 2
  Front Node: pto.load_dps
    DefVec (Size 1):
 - Root: arith.constant | Scope: 2
    UseVec (Size 1):
 - Root: BlockArg | Scope: 1
  -> Already Synced at Pipe Level. Skipping.

[MemAnalyze] Analyzing Dependency:
  Now Node: pto.store_dps
    DefVec (Size 1):
 - Root: BlockArg | Scope: 1
    UseVec (Size 1):
 - Root: arith.constant | Scope: 5
  Front Node: pto.store_dps
    DefVec (Size 1):
 - Root: BlockArg | Scope: 1
    UseVec (Size 1):
 - Root: arith.constant | Scope: 5
  -> Already Synced at Pipe Level. Skipping.

[MemAnalyze] Analyzing Dependency:
  Now Node: pto.store_dps
    DefVec (Size 1):
 - Root: BlockArg | Scope: 1
    UseVec (Size 1):
 - Root: arith.constant | Scope: 5
  Front Node: pto.mov_dps
    DefVec (Size 1):
 - Root: arith.constant | Scope: 4
    UseVec (Size 1):
 - Root: arith.constant | Scope: 2
  -> Already Synced at Pipe Level. Skipping.

[MemAnalyze] Analyzing Dependency:
  Now Node: pto.store_dps
    DefVec (Size 1):
 - Root: BlockArg | Scope: 1
    UseVec (Size 1):
 - Root: arith.constant | Scope: 5
  Front Node: pto.mov_dps
    DefVec (Size 1):
 - Root: arith.constant | Scope: 3
    UseVec (Size 1):
 - Root: arith.constant | Scope: 2
  -> Already Synced at Pipe Level. Skipping.

[MemAnalyze] Analyzing Dependency:
  Now Node: pto.store_dps
    DefVec (Size 1):
 - Root: BlockArg | Scope: 1
    UseVec (Size 1):
 - Root: arith.constant | Scope: 5
  Front Node: pto.load_dps
    DefVec (Size 1):
 - Root: arith.constant | Scope: 2
    UseVec (Size 1):
 - Root: BlockArg | Scope: 1
  -> Already Synced at Pipe Level. Skipping.

[MemAnalyze] Analyzing Dependency:
  Now Node: pto.store_dps
    DefVec (Size 1):
 - Root: BlockArg | Scope: 1
    UseVec (Size 1):
 - Root: arith.constant | Scope: 5
  Front Node: pto.load_dps
    DefVec (Size 1):
 - Root: arith.constant | Scope: 2
    UseVec (Size 1):
 - Root: BlockArg | Scope: 1
  -> Already Synced at Pipe Level. Skipping.

[MemAnalyze] Analyzing Dependency:
  Now Node: pto.store_dps
    DefVec (Size 1):
 - Root: BlockArg | Scope: 1
    UseVec (Size 1):
 - Root: arith.constant | Scope: 5
  Front Node: pto.matmul_dps
    DefVec (Size 1):
 - Root: arith.constant | Scope: 5
    UseVec (Size 2):
 - Root: arith.constant | Scope: 3
 - Root: arith.constant | Scope: 4
  -> Already Synced at Pipe Level. Skipping.

[MemAnalyze] Analyzing Dependency:
  Now Node: pto.store_dps
    DefVec (Size 1):
 - Root: BlockArg | Scope: 1
    UseVec (Size 1):
 - Root: arith.constant | Scope: 5
  Front Node: pto.mov_dps
    DefVec (Size 1):
 - Root: arith.constant | Scope: 4
    UseVec (Size 1):
 - Root: arith.constant | Scope: 2
  -> Already Synced at Pipe Level. Skipping.

[MemAnalyze] Analyzing Dependency:
  Now Node: pto.store_dps
    DefVec (Size 1):
 - Root: BlockArg | Scope: 1
    UseVec (Size 1):
 - Root: arith.constant | Scope: 5
  Front Node: pto.mov_dps
    DefVec (Size 1):
 - Root: arith.constant | Scope: 3
    UseVec (Size 1):
 - Root: arith.constant | Scope: 2
  -> Already Synced at Pipe Level. Skipping.

[MemAnalyze] Analyzing Dependency:
  Now Node: pto.store_dps
    DefVec (Size 1):
 - Root: BlockArg | Scope: 1
    UseVec (Size 1):
 - Root: arith.constant | Scope: 5
  Front Node: pto.load_dps
    DefVec (Size 1):
 - Root: arith.constant | Scope: 2
    UseVec (Size 1):
 - Root: BlockArg | Scope: 1
  -> Already Synced at Pipe Level. Skipping.

[MemAnalyze] Analyzing Dependency:
  Now Node: pto.store_dps
    DefVec (Size 1):
 - Root: BlockArg | Scope: 1
    UseVec (Size 1):
 - Root: arith.constant | Scope: 5
  Front Node: pto.load_dps
    DefVec (Size 1):
 - Root: arith.constant | Scope: 2
    UseVec (Size 1):
 - Root: BlockArg | Scope: 1
  -> Already Synced at Pipe Level. Skipping.

[InsertLastPipeAll] Scan backwards for injection point...
  Scanning Node 25 Kind: BRANCH
  [Trace Insert] Final Barrier at Node 25 (POST)

// === [PTOInsertSync Debug] After Analysis === //
Node 0: 
Node 1: 
Node 2: Loop
Node 3: Loop
Node 4: pto.load_dps (Pipe 4)
  POST: set_flag (4->3)
Node 5: pto.load_dps (Pipe 4)
  POST: set_flag (4->3)
Node 6: pto.mov_dps (Pipe 3)
  PRE: wait_flag (4->3)
  POST: set_flag (3->2)
  POST: set_flag (3->4)
Node 7: pto.mov_dps (Pipe 3)
  PRE: wait_flag (4->3)
  POST: set_flag (3->2)
  POST: set_flag (3->4)
Node 8: pto.matmul_dps (Pipe 2)
  PRE: wait_flag (3->2)
  PRE: wait_flag (3->2)
  PRE: wait_flag (5->2)
  POST: set_flag (2->3)
  POST: set_flag (2->5)
Node 9: Loop
Node 10: pto.load_dps (Pipe 4)
  PRE: wait_flag (3->4)
  PRE: wait_flag (3->4)
  POST: set_flag (4->3)
Node 11: pto.load_dps (Pipe 4)
  PRE: wait_flag (3->4)
  PRE: wait_flag (3->4)
  POST: set_flag (4->3)
Node 12: pto.mov_dps (Pipe 3)
  PRE: wait_flag (4->3)
  PRE: wait_flag (2->3)
  POST: set_flag (3->4)
Node 13: pto.mov_dps (Pipe 3)
  PRE: wait_flag (4->3)
  POST: set_flag (3->4)
Node 14: Loop
Node 15: pto.store_dps (Pipe 5)
  PRE: wait_flag (2->5)
  POST: set_flag (5->2)
Node 16: Loop
Node 17: Loop
Node 18: 
Node 19: 
Node 20: 
Node 21: 
Node 22: 
Node 23: 
Node 24: 
Node 25: 
  POST: pipe_barrier (6->6)
// ========================================= //

// === [PTOInsertSync Debug] After Sync Motion === //
Node 0: 
Node 1: 
Node 2: Loop
Node 3: Loop
Node 4: pto.load_dps (Pipe 4)
  POST: set_flag (4->3)
Node 5: pto.load_dps (Pipe 4)
  POST: set_flag (4->3)
Node 6: pto.mov_dps (Pipe 3)
  PRE: wait_flag (4->3)
  POST: set_flag (3->2)
  POST: set_flag (3->4)
Node 7: pto.mov_dps (Pipe 3)
  PRE: wait_flag (4->3)
  POST: set_flag (3->2)
  POST: set_flag (3->4)
Node 8: pto.matmul_dps (Pipe 2)
  PRE: wait_flag (3->2)
  PRE: wait_flag (3->2)
  PRE: wait_flag (5->2)
  POST: set_flag (2->3)
  POST: set_flag (2->5)
Node 9: Loop
  PRE: wait_flag (3->4)
  PRE: wait_flag (3->4)
  PRE: wait_flag (2->3)
Node 10: pto.load_dps (Pipe 4)
  PRE: wait_flag (3->4)
  POST: set_flag (4->3)
Node 11: pto.load_dps (Pipe 4)
  PRE: wait_flag (3->4)
  POST: set_flag (4->3)
Node 12: pto.mov_dps (Pipe 3)
  PRE: wait_flag (4->3)
  POST: set_flag (3->4)
Node 13: pto.mov_dps (Pipe 3)
  PRE: wait_flag (4->3)
  POST: set_flag (3->4)
Node 14: Loop
Node 15: pto.store_dps (Pipe 5)
  PRE: wait_flag (2->5)
  POST: set_flag (5->2)
Node 16: Loop
Node 17: Loop
Node 18: 
Node 19: 
Node 20: 
Node 21: 
Node 22: 
Node 23: 
Node 24: 
Node 25: 
  POST: pipe_barrier (6->6)
// ========================================= //

// === [PTOInsertSync Debug] After Optimization === //
Node 0: 
Node 1: 
Node 2: Loop
Node 3: Loop
Node 4: pto.load_dps (Pipe 4)
  POST: set_flag (4->3)
Node 5: pto.load_dps (Pipe 4)
  POST: set_flag (4->3)
Node 6: pto.mov_dps (Pipe 3)
  PRE: wait_flag (4->3)
Node 7: pto.mov_dps (Pipe 3)
  PRE: wait_flag (4->3)
  POST: set_flag (3->2)
  POST: set_flag (3->4)
Node 8: pto.matmul_dps (Pipe 2)
  PRE: wait_flag (3->2)
  PRE: wait_flag (5->2)
  POST: set_flag (2->3)
  POST: set_flag (2->5)
Node 9: Loop
  PRE: wait_flag (3->4)
  PRE: wait_flag (2->3)
Node 10: pto.load_dps (Pipe 4)
  PRE: wait_flag (3->4)
  POST: set_flag (4->3)
Node 11: pto.load_dps (Pipe 4)
  PRE: wait_flag (3->4)
  POST: set_flag (4->3)
Node 12: pto.mov_dps (Pipe 3)
  PRE: wait_flag (4->3)
  POST: set_flag (3->4)
Node 13: pto.mov_dps (Pipe 3)
  PRE: wait_flag (4->3)
  POST: set_flag (3->4)
Node 14: Loop
Node 15: pto.store_dps (Pipe 5)
  PRE: wait_flag (2->5)
  POST: set_flag (5->2)
Node 16: Loop
Node 17: Loop
Node 18: 
Node 19: 
Node 20: 
Node 21: 
Node 22: 
Node 23: 
Node 24: 
Node 25: 
  POST: pipe_barrier (6->6)
// ========================================= //
begin: 4 end: 6
begin: 5 end: 7
begin: 7 end: 8
begin: 0 end: 25
begin: 7 end: 9
begin: 8 end: 9
begin: 0 end: 25
begin: 0 end: 25
begin: 10 end: 12
begin: 11 end: 13
begin: 8 end: 15

// === [PTOInsertSync Debug] After EventId Allocation === //
Node 0: 
  PRE: set_flag (5->2) [ID:0,]
  PRE: set_flag (3->4) [ID:1,]
  PRE: set_flag (3->4) [ID:2,]
Node 1: 
Node 2: Loop
Node 3: Loop
Node 4: pto.load_dps (Pipe 4)
  POST: set_flag (4->3) [ID:0,]
Node 5: pto.load_dps (Pipe 4)
  POST: set_flag (4->3) [ID:1,]
Node 6: pto.mov_dps (Pipe 3)
  PRE: wait_flag (4->3) [ID:0,]
Node 7: pto.mov_dps (Pipe 3)
  PRE: wait_flag (4->3) [ID:1,]
  POST: set_flag (3->2) [ID:0,]
  POST: set_flag (3->4) [ID:0,]
Node 8: pto.matmul_dps (Pipe 2)
  PRE: wait_flag (3->2) [ID:0,]
  PRE: wait_flag (5->2) [ID:0,]
  POST: set_flag (2->3) [ID:0,]
  POST: set_flag (2->5) [ID:0,]
Node 9: Loop
  PRE: wait_flag (3->4) [ID:0,]
  PRE: wait_flag (2->3) [ID:0,]
Node 10: pto.load_dps (Pipe 4)
  PRE: wait_flag (3->4) [ID:1,]
  POST: set_flag (4->3) [ID:2,]
Node 11: pto.load_dps (Pipe 4)
  PRE: wait_flag (3->4) [ID:2,]
  POST: set_flag (4->3) [ID:3,]
Node 12: pto.mov_dps (Pipe 3)
  PRE: wait_flag (4->3) [ID:2,]
  POST: set_flag (3->4) [ID:1,]
Node 13: pto.mov_dps (Pipe 3)
  PRE: wait_flag (4->3) [ID:3,]
  POST: set_flag (3->4) [ID:2,]
Node 14: Loop
Node 15: pto.store_dps (Pipe 5)
  PRE: wait_flag (2->5) [ID:0,]
  POST: set_flag (5->2) [ID:0,]
Node 16: Loop
Node 17: Loop
Node 18: 
Node 19: 
Node 20: 
Node 21: 
Node 22: 
Node 23: 
Node 24: 
Node 25: 
  POST: pipe_barrier (6->6)
  POST: wait_flag (5->2) [ID:0,]
  POST: wait_flag (3->4) [ID:1,]
  POST: wait_flag (3->4) [ID:2,]
// ========================================= //

// === [PTOInsertSync] Final Result === //
func.func @bgemm_kernel(%arg0: index, %arg1: memref<?xf16, #pto.address_space<gm>>, %arg2: memref<?xf16, #pto.address_space<gm>>, %arg3: memref<?xf32, #pto.address_space<gm>>) {
  %true = arith.constant true
  %c4 = arith.constant 4 : index
  %c2 = arith.constant 2 : index
  %c16384_i64 = arith.constant 16384 : i64
  %c0_i64 = arith.constant 0 : i64
  %c0 = arith.constant 0 : index
  %c64 = arith.constant 64 : index
  %c128 = arith.constant 128 : index
  %c1 = arith.constant 1 : index
  %c256 = arith.constant 256 : index
  %reinterpret_cast = memref.reinterpret_cast %arg1 to offset: [0], sizes: [%c1, %c1, %c1, %c256, %c256], strides: [%c1, %c1, %c1, %c256, %c1] : memref<?xf16, #pto.address_space<gm>> to memref<?x?x?x?x?xf16, strided<[?, ?, ?, ?, ?], offset: ?>, #pto.address_space<gm>>
  %reinterpret_cast_0 = memref.reinterpret_cast %arg2 to offset: [0], sizes: [%c1, %c1, %c1, %c256, %c256], strides: [%c1, %c1, %c1, %c1, %c256] : memref<?xf16, #pto.address_space<gm>> to memref<?x?x?x?x?xf16, strided<[?, ?, ?, ?, ?], offset: ?>, #pto.address_space<gm>>
  %reinterpret_cast_1 = memref.reinterpret_cast %arg3 to offset: [0], sizes: [%c1, %c1, %c1, %c256, %c256], strides: [%c1, %c1, %c1, %c256, %c1] : memref<?xf32, #pto.address_space<gm>> to memref<?x?x?x?x?xf32, strided<[?, ?, ?, ?, ?], offset: ?>, #pto.address_space<gm>>
  %0 = pto.pointer_cast(%c0_i64) : memref<128x64xf16, strided<[64, 1]>, #pto.address_space<mat>>
  %1 = pto.bind_tile %0 {config = #pto.tile_buf_config<blayout=1 : i32, slayout=1 : i32, s_fractal_size=512, pad=0 : i32>} : memref<128x64xf16, strided<[64, 1]>, #pto.address_space<mat>> -> memref<128x64xf16, strided<[64, 1], offset: ?>, #pto.address_space<mat>>
  %2 = pto.pointer_cast(%c16384_i64) : memref<64x256xf16, strided<[256, 1]>, #pto.address_space<mat>>
  %3 = pto.bind_tile %2 {config = #pto.tile_buf_config<blayout=0 : i32, slayout=2 : i32, s_fractal_size=512, pad=0 : i32>} : memref<64x256xf16, strided<[256, 1]>, #pto.address_space<mat>> -> memref<64x256xf16, strided<[256, 1], offset: ?>, #pto.address_space<mat>>
  %4 = pto.pointer_cast(%c0_i64) : memref<128x64xf16, strided<[64, 1]>, #pto.address_space<left>>
  %5 = pto.bind_tile %4 {config = #pto.tile_buf_config<blayout=0 : i32, slayout=1 : i32, s_fractal_size=512, pad=0 : i32>} : memref<128x64xf16, strided<[64, 1]>, #pto.address_space<left>> -> memref<128x64xf16, strided<[64, 1], offset: ?>, #pto.address_space<left>>
  %6 = pto.pointer_cast(%c0_i64) : memref<64x256xf16, strided<[256, 1]>, #pto.address_space<right>>
  %7 = pto.bind_tile %6 {config = #pto.tile_buf_config<blayout=0 : i32, slayout=2 : i32, s_fractal_size=512, pad=0 : i32>} : memref<64x256xf16, strided<[256, 1]>, #pto.address_space<right>> -> memref<64x256xf16, strided<[256, 1], offset: ?>, #pto.address_space<right>>
  %8 = pto.pointer_cast(%c0_i64) : memref<128x256xf32, strided<[256, 1]>, #pto.address_space<acc>>
  %9 = pto.bind_tile %8 {config = #pto.tile_buf_config<blayout=1 : i32, slayout=1 : i32, s_fractal_size=1024, pad=0 : i32>} : memref<128x256xf32, strided<[256, 1]>, #pto.address_space<acc>> -> memref<128x256xf32, strided<[256, 1], offset: ?>, #pto.address_space<acc>>
  %10 = arith.cmpi slt, %arg0, %c1 : index
  pto.set_flag[<PIPE_MTE3>, <PIPE_M>, <EVENT_ID0>]
  pto.set_flag[<PIPE_MTE1>, <PIPE_MTE2>, <EVENT_ID1>]
  pto.set_flag[<PIPE_MTE1>, <PIPE_MTE2>, <EVENT_ID2>]
  scf.if %10 {
    scf.if %true {
      %11 = arith.muli %arg0, %c256 : index
      %12 = arith.muli %arg0, %c256 : index
      scf.for %arg4 = %c0 to %c2 step %c1 {
        %13 = arith.muli %arg4, %c128 : index
        %14 = arith.addi %11, %13 : index
        scf.for %arg5 = %c0 to %c1 step %c1 {
          %15 = arith.muli %arg5, %c256 : index
          %subview = memref.subview %reinterpret_cast[0, 0, 0, %14, 0] [1, 1, 1, 128, 64] [1, 1, 1, 1, 1] : memref<?x?x?x?x?xf16, strided<[?, ?, ?, ?, ?], offset: ?>, #pto.address_space<gm>> to memref<1x1x1x128x64xf16, strided<[?, ?, ?, ?, ?], offset: ?>, #pto.address_space<gm>>
          pto.load_dps ins(%subview : memref<1x1x1x128x64xf16, strided<[?, ?, ?, ?, ?], offset: ?>, #pto.address_space<gm>>) outs(%1 : memref<128x64xf16, strided<[64, 1], offset: ?>, #pto.address_space<mat>>)
          pto.set_flag[<PIPE_MTE2>, <PIPE_MTE1>, <EVENT_ID0>]
          %subview_2 = memref.subview %reinterpret_cast_0[0, 0, 0, %12, %15] [1, 1, 1, 64, 256] [1, 1, 1, 1, 1] : memref<?x?x?x?x?xf16, strided<[?, ?, ?, ?, ?], offset: ?>, #pto.address_space<gm>> to memref<1x1x1x64x256xf16, strided<[?, ?, ?, ?, ?], offset: ?>, #pto.address_space<gm>>
          pto.load_dps ins(%subview_2 : memref<1x1x1x64x256xf16, strided<[?, ?, ?, ?, ?], offset: ?>, #pto.address_space<gm>>) outs(%3 : memref<64x256xf16, strided<[256, 1], offset: ?>, #pto.address_space<mat>>)
          pto.set_flag[<PIPE_MTE2>, <PIPE_MTE1>, <EVENT_ID1>]
          pto.wait_flag[<PIPE_MTE2>, <PIPE_MTE1>, <EVENT_ID0>]
          pto.mov_dps ins(%1 : memref<128x64xf16, strided<[64, 1], offset: ?>, #pto.address_space<mat>>) outs(%5 : memref<128x64xf16, strided<[64, 1], offset: ?>, #pto.address_space<left>>)
          pto.barrier <PIPE_ALL>
          pto.wait_flag[<PIPE_MTE2>, <PIPE_MTE1>, <EVENT_ID1>]
          pto.mov_dps ins(%3 : memref<64x256xf16, strided<[256, 1], offset: ?>, #pto.address_space<mat>>) outs(%7 : memref<64x256xf16, strided<[256, 1], offset: ?>, #pto.address_space<right>>)
          pto.barrier <PIPE_ALL>
          pto.set_flag[<PIPE_MTE1>, <PIPE_M>, <EVENT_ID0>]
          pto.set_flag[<PIPE_MTE1>, <PIPE_MTE2>, <EVENT_ID0>]
          pto.wait_flag[<PIPE_MTE1>, <PIPE_M>, <EVENT_ID0>]
          pto.wait_flag[<PIPE_MTE3>, <PIPE_M>, <EVENT_ID0>]
          pto.matmul_dps ins(%5, %7 : memref<128x64xf16, strided<[64, 1], offset: ?>, #pto.address_space<left>>, memref<64x256xf16, strided<[256, 1], offset: ?>, #pto.address_space<right>>) outs(%9 : memref<128x256xf32, strided<[256, 1], offset: ?>, #pto.address_space<acc>>)
          pto.barrier <PIPE_ALL>
          pto.set_flag[<PIPE_M>, <PIPE_MTE1>, <EVENT_ID0>]
          pto.set_flag[<PIPE_M>, <PIPE_MTE3>, <EVENT_ID0>]
          pto.wait_flag[<PIPE_MTE1>, <PIPE_MTE2>, <EVENT_ID0>]
          pto.wait_flag[<PIPE_M>, <PIPE_MTE1>, <EVENT_ID0>]
          scf.for %arg6 = %c1 to %c4 step %c1 {
            %16 = arith.muli %arg6, %c64 : index
            %subview_4 = memref.subview %reinterpret_cast[0, 0, 0, %14, %16] [1, 1, 1, 128, 64] [1, 1, 1, 1, 1] : memref<?x?x?x?x?xf16, strided<[?, ?, ?, ?, ?], offset: ?>, #pto.address_space<gm>> to memref<1x1x1x128x64xf16, strided<[?, ?, ?, ?, ?], offset: ?>, #pto.address_space<gm>>
            pto.wait_flag[<PIPE_MTE1>, <PIPE_MTE2>, <EVENT_ID1>]
            pto.load_dps ins(%subview_4 : memref<1x1x1x128x64xf16, strided<[?, ?, ?, ?, ?], offset: ?>, #pto.address_space<gm>>) outs(%1 : memref<128x64xf16, strided<[64, 1], offset: ?>, #pto.address_space<mat>>)
            pto.set_flag[<PIPE_MTE2>, <PIPE_MTE1>, <EVENT_ID2>]
            %17 = arith.addi %12, %16 : index
            %subview_5 = memref.subview %reinterpret_cast_0[0, 0, 0, %17, %15] [1, 1, 1, 64, 256] [1, 1, 1, 1, 1] : memref<?x?x?x?x?xf16, strided<[?, ?, ?, ?, ?], offset: ?>, #pto.address_space<gm>> to memref<1x1x1x64x256xf16, strided<[?, ?, ?, ?, ?], offset: ?>, #pto.address_space<gm>>
            pto.wait_flag[<PIPE_MTE1>, <PIPE_MTE2>, <EVENT_ID2>]
            pto.load_dps ins(%subview_5 : memref<1x1x1x64x256xf16, strided<[?, ?, ?, ?, ?], offset: ?>, #pto.address_space<gm>>) outs(%3 : memref<64x256xf16, strided<[256, 1], offset: ?>, #pto.address_space<mat>>)
            pto.set_flag[<PIPE_MTE2>, <PIPE_MTE1>, <EVENT_ID3>]
            pto.wait_flag[<PIPE_MTE2>, <PIPE_MTE1>, <EVENT_ID2>]
            pto.mov_dps ins(%1 : memref<128x64xf16, strided<[64, 1], offset: ?>, #pto.address_space<mat>>) outs(%5 : memref<128x64xf16, strided<[64, 1], offset: ?>, #pto.address_space<left>>)
            pto.barrier <PIPE_ALL>
            pto.set_flag[<PIPE_MTE1>, <PIPE_MTE2>, <EVENT_ID1>]
            pto.wait_flag[<PIPE_MTE2>, <PIPE_MTE1>, <EVENT_ID3>]
            pto.mov_dps ins(%3 : memref<64x256xf16, strided<[256, 1], offset: ?>, #pto.address_space<mat>>) outs(%7 : memref<64x256xf16, strided<[256, 1], offset: ?>, #pto.address_space<right>>)
            pto.barrier <PIPE_ALL>
            pto.set_flag[<PIPE_MTE1>, <PIPE_MTE2>, <EVENT_ID2>]
            pto.matmul_acc_dps ins(%9, %5, %7 : memref<128x256xf32, strided<[256, 1], offset: ?>, #pto.address_space<acc>>, memref<128x64xf16, strided<[64, 1], offset: ?>, #pto.address_space<left>>, memref<64x256xf16, strided<[256, 1], offset: ?>, #pto.address_space<right>>) outs(%9 : memref<128x256xf32, strided<[256, 1], offset: ?>, #pto.address_space<acc>>)
            pto.barrier <PIPE_ALL>
          }
          %subview_3 = memref.subview %reinterpret_cast_1[0, 0, 0, %14, %15] [1, 1, 1, 128, 256] [1, 1, 1, 1, 1] : memref<?x?x?x?x?xf32, strided<[?, ?, ?, ?, ?], offset: ?>, #pto.address_space<gm>> to memref<1x1x1x128x256xf32, strided<[?, ?, ?, ?, ?], offset: ?>, #pto.address_space<gm>>
          pto.wait_flag[<PIPE_M>, <PIPE_MTE3>, <EVENT_ID0>]
          pto.store_dps ins(%9 : memref<128x256xf32, strided<[256, 1], offset: ?>, #pto.address_space<acc>>) outs(%subview_3 : memref<1x1x1x128x256xf32, strided<[?, ?, ?, ?, ?], offset: ?>, #pto.address_space<gm>>)
          pto.set_flag[<PIPE_MTE3>, <PIPE_M>, <EVENT_ID0>]
        }
      }
    }
  }
  pto.barrier <PIPE_ALL>
  pto.wait_flag[<PIPE_MTE3>, <PIPE_M>, <EVENT_ID0>]
  pto.wait_flag[<PIPE_MTE1>, <PIPE_MTE2>, <EVENT_ID1>]
  pto.wait_flag[<PIPE_MTE1>, <PIPE_MTE2>, <EVENT_ID2>]
  return
}

// === [PTOInsertSync] End === //
DEBUG: Start PTOToEmitC Pass
[Debug] Converting MemRef: memref<?xf16, #pto.address_space<gm>>
  [Success] -> __gm__ half*
[Debug] Converting MemRef: memref<?xf32, #pto.address_space<gm>>
  [Success] -> __gm__ float*
[Debug] Converting MemRef: memref<128x64xf16, strided<[64, 1]>, #pto.address_space<mat>>
  [Success] -> __mat__ half*
[Debug] Converting MemRef: memref<64x256xf16, strided<[256, 1]>, #pto.address_space<mat>>
  [Success] -> __mat__ half*
[Debug] Converting MemRef: memref<128x64xf16, strided<[64, 1]>, #pto.address_space<left>>
  [Success] -> __left__ half*
[Debug] Converting MemRef: memref<64x256xf16, strided<[256, 1]>, #pto.address_space<right>>
  [Success] -> __right__ half*
[Debug] Converting MemRef: memref<128x256xf32, strided<[256, 1]>, #pto.address_space<acc>>
  [Success] -> __acc__ float*
[Debug] Converting MemRef: memref<?x?x?x?x?xf16, strided<[?, ?, ?, ?, ?], offset: ?>, #pto.address_space<gm>>
  [Success] -> __gm__ half*
[Debug] Converting MemRef: memref<1x1x1x128x64xf16, strided<[?, ?, ?, ?, ?], offset: ?>, #pto.address_space<gm>>
  [Success] -> __gm__ half*
[Debug] Converting MemRef: memref<128x64xf16, strided<[64, 1], offset: ?>, #pto.address_space<mat>>
  [Success] -> __mat__ half*
[Debug] Converting MemRef: memref<1x1x1x64x256xf16, strided<[?, ?, ?, ?, ?], offset: ?>, #pto.address_space<gm>>
  [Success] -> __gm__ half*
[Debug] Converting MemRef: memref<64x256xf16, strided<[256, 1], offset: ?>, #pto.address_space<mat>>
  [Success] -> __mat__ half*
[Debug] Converting MemRef: memref<128x64xf16, strided<[64, 1], offset: ?>, #pto.address_space<left>>
  [Success] -> __left__ half*
[Debug] Converting MemRef: memref<64x256xf16, strided<[256, 1], offset: ?>, #pto.address_space<right>>
  [Success] -> __right__ half*
[Debug] Converting MemRef: memref<128x256xf32, strided<[256, 1], offset: ?>, #pto.address_space<acc>>
  [Success] -> __acc__ float*
[Debug] Converting MemRef: memref<?x?x?x?x?xf32, strided<[?, ?, ?, ?, ?], offset: ?>, #pto.address_space<gm>>
  [Success] -> __gm__ float*
[Debug] Converting MemRef: memref<1x1x1x128x256xf32, strided<[?, ?, ?, ?, ?], offset: ?>, #pto.address_space<gm>>
  [Success] -> __gm__ float*
PTO Driver Success!!!
